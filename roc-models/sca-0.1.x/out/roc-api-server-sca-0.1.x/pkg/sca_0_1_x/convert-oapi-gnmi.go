// Package sca_0_1_x provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/intel-innersource/frameworks.edge.one-intel-edge.maestro-app.roc.rocaas-tools/rocaas-cli version (devel) DO NOT EDIT.
package sca_0_1_x

import (
	"fmt"
	"strings"

	externalRef0 "github.com/intel-innersource/frameworks.edge.one-intel-edge.springboard.reference-implementation.roc-models/models/sca-0.1.x/api"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	// Not generating constants
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	// Not generating constants
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertiesUnchTarget

//Ignoring AdditionalPropertyCityId

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiCollisionDetection converts OAPI to gNMI.
func EncodeToGnmiCollisionDetection(
	jsonObj *CollisionDetection, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: detection-application CollisionDetectionDetectionApplication
	if jsonObj.DetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiCollisionDetectionDetectionApplication(
			jsonObj.DetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: district CollisionDetectionDistrictList
	if jsonObj.District != nil { // Optional leaf

		update, err := EncodeToGnmiCollisionDetectionDistrictList(
			jsonObj.District, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "district"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "CollisionDetection", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiCollisionDetectionDetectionApplication(
	jsonObj *CollisionDetectionDetectionApplication, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state CollisionDetectionDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiCollisionDetectionDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "CollisionDetectionDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiCollisionDetectionDetectionApplicationDevice(
	jsonObj *CollisionDetectionDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiCollisionDetectionDetectionApplicationPrecision(
	jsonObj *CollisionDetectionDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiCollisionDetectionDetectionApplicationModelState(
	jsonObj *CollisionDetectionDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "CollisionDetectionDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDistrict converts OAPI to gNMI.
func EncodeToGnmiCollisionDetectionDistrict(
	jsonObj *CollisionDetectionDistrict, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: district-ref ListKey
	_, unchangedDistrictRef := unchangedAttrs["district-ref"]
	if !unchangedDistrictRef { // Mandatory leaf

		paramsDistrictRef := make([]string, len(params))
		copy(paramsDistrictRef, params)
		stringValDistrictRef := fmt.Sprintf("%v", jsonObj.DistrictRef)

		paramsDistrictRef = append(paramsDistrictRef, stringValDistrictRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDistrictDistrictRef", paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/district-ref"), paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDistrictEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "CollisionDetectionDistrictStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "CollisionDetectionDistrict", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiCollisionDetectionDistrictList converts OAPI List to gNMI List.
func EncodeToGnmiCollisionDetectionDistrictList(
	jsonObj *CollisionDetectionDistrictList, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiCollisionDetectionDistrict(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiDistrict converts OAPI to gNMI.
func EncodeToGnmiDistrict(
	jsonObj *District, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: district-id ListKey
	_, unchangedDistrictId := unchangedAttrs["district-id"]
	if !unchangedDistrictId { // Mandatory leaf

		paramsDistrictId := make([]string, len(params))
		copy(paramsDistrictId, params)
		stringValDistrictId := fmt.Sprintf("%v", jsonObj.DistrictId)

		paramsDistrictId = append(paramsDistrictId, stringValDistrictId)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictDistrictId", paramsDistrictId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/district-id"), paramsDistrictId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: image string
	if jsonObj.Image != nil { // Optional leaf

		paramsImage := make([]string, len(params))
		copy(paramsImage, params)
		stringValImage := fmt.Sprintf("%v", *jsonObj.Image)

		paramsImage = append(paramsImage, stringValImage)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictImage", paramsImage...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/image"), paramsImage...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: location DistrictLocation
	if jsonObj.Location != nil { // Optional leaf

		update, err := EncodeToGnmiDistrictLocation(
			jsonObj.Location, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "location"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: source DistrictSourceList
	if jsonObj.Source != nil { // Optional leaf

		update, err := EncodeToGnmiDistrictSourceList(
			jsonObj.Source, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "source"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "District", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictList converts OAPI List to gNMI List.
func EncodeToGnmiDistrictList(
	jsonObj *DistrictList, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiDistrict(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiDistrictLocation converts OAPI to gNMI.
func EncodeToGnmiDistrictLocation(
	jsonObj *DistrictLocation, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: coordinate-system string
	_, unchangedCoordinateSystem := unchangedAttrs["coordinate-system"]
	if !unchangedCoordinateSystem { // Mandatory leaf

		paramsCoordinateSystem := make([]string, len(params))
		copy(paramsCoordinateSystem, params)
		paramsCoordinateSystem = append(paramsCoordinateSystem, (string)(jsonObj.CoordinateSystem))
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationCoordinateSystem", paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/coordinate-system"), paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: orientation-x int64
	if jsonObj.OrientationX != nil { // Optional leaf

		paramsOrientationX := make([]string, len(params))
		copy(paramsOrientationX, params)
		stringValOrientationX := fmt.Sprintf("%v", *jsonObj.OrientationX)

		paramsOrientationX = append(paramsOrientationX, stringValOrientationX)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationOrientationX", paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/orientation-x"), paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: x int64
	_, unchangedX := unchangedAttrs["x"]
	if !unchangedX { // Mandatory leaf

		paramsX := make([]string, len(params))
		copy(paramsX, params)
		stringValX := fmt.Sprintf("%v", jsonObj.X)

		paramsX = append(paramsX, stringValX)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationX", paramsX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/x"), paramsX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: y int64
	_, unchangedY := unchangedAttrs["y"]
	if !unchangedY { // Mandatory leaf

		paramsY := make([]string, len(params))
		copy(paramsY, params)
		stringValY := fmt.Sprintf("%v", jsonObj.Y)

		paramsY = append(paramsY, stringValY)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationY", paramsY...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/y"), paramsY...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: z int64
	if jsonObj.Z != nil { // Optional leaf

		paramsZ := make([]string, len(params))
		copy(paramsZ, params)
		stringValZ := fmt.Sprintf("%v", *jsonObj.Z)

		paramsZ = append(paramsZ, stringValZ)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationZ", paramsZ...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/z"), paramsZ...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DistrictLocation", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictLocationCoordinateSystem converts OAPI to gNMI.
func EncodeToGnmiDistrictLocationCoordinateSystem(
	jsonObj *DistrictLocationCoordinateSystem, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "DistrictLocationCoordinateSystem", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiDistrictSource converts OAPI to gNMI.
func EncodeToGnmiDistrictSource(
	jsonObj *DistrictSource, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: image string
	if jsonObj.Image != nil { // Optional leaf

		paramsImage := make([]string, len(params))
		copy(paramsImage, params)
		stringValImage := fmt.Sprintf("%v", *jsonObj.Image)

		paramsImage = append(paramsImage, stringValImage)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceImage", paramsImage...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/image"), paramsImage...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: location DistrictSourceLocation
	if jsonObj.Location != nil { // Optional leaf

		update, err := EncodeToGnmiDistrictSourceLocation(
			jsonObj.Location, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "location"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: source-id ListKey
	_, unchangedSourceId := unchangedAttrs["source-id"]
	if !unchangedSourceId { // Mandatory leaf

		paramsSourceId := make([]string, len(params))
		copy(paramsSourceId, params)
		stringValSourceId := fmt.Sprintf("%v", jsonObj.SourceId)

		paramsSourceId = append(paramsSourceId, stringValSourceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceSourceId", paramsSourceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/source-id"), paramsSourceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: state DistrictSourceState
	if jsonObj.State != nil { // Optional leaf

		update, err := EncodeToGnmiDistrictSourceState(
			jsonObj.State, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: video DistrictSourceVideo
	if jsonObj.Video != nil { // Optional leaf

		update, err := EncodeToGnmiDistrictSourceVideo(
			jsonObj.Video, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "video"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DistrictSource", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictSourceList converts OAPI List to gNMI List.
func EncodeToGnmiDistrictSourceList(
	jsonObj *DistrictSourceList, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiDistrictSource(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiDistrictSourceLocation converts OAPI to gNMI.
func EncodeToGnmiDistrictSourceLocation(
	jsonObj *DistrictSourceLocation, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: coordinate-system string
	_, unchangedCoordinateSystem := unchangedAttrs["coordinate-system"]
	if !unchangedCoordinateSystem { // Mandatory leaf

		paramsCoordinateSystem := make([]string, len(params))
		copy(paramsCoordinateSystem, params)
		paramsCoordinateSystem = append(paramsCoordinateSystem, (string)(jsonObj.CoordinateSystem))
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationCoordinateSystem", paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/coordinate-system"), paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: orientation-x int64
	if jsonObj.OrientationX != nil { // Optional leaf

		paramsOrientationX := make([]string, len(params))
		copy(paramsOrientationX, params)
		stringValOrientationX := fmt.Sprintf("%v", *jsonObj.OrientationX)

		paramsOrientationX = append(paramsOrientationX, stringValOrientationX)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationOrientationX", paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/orientation-x"), paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: x int64
	_, unchangedX := unchangedAttrs["x"]
	if !unchangedX { // Mandatory leaf

		paramsX := make([]string, len(params))
		copy(paramsX, params)
		stringValX := fmt.Sprintf("%v", jsonObj.X)

		paramsX = append(paramsX, stringValX)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationX", paramsX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/x"), paramsX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: y int64
	_, unchangedY := unchangedAttrs["y"]
	if !unchangedY { // Mandatory leaf

		paramsY := make([]string, len(params))
		copy(paramsY, params)
		stringValY := fmt.Sprintf("%v", jsonObj.Y)

		paramsY = append(paramsY, stringValY)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationY", paramsY...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/y"), paramsY...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: z int64
	if jsonObj.Z != nil { // Optional leaf

		paramsZ := make([]string, len(params))
		copy(paramsZ, params)
		stringValZ := fmt.Sprintf("%v", *jsonObj.Z)

		paramsZ = append(paramsZ, stringValZ)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationZ", paramsZ...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/z"), paramsZ...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DistrictSourceLocation", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictSourceLocationCoordinateSystem converts OAPI to gNMI.
func EncodeToGnmiDistrictSourceLocationCoordinateSystem(
	jsonObj *DistrictSourceLocationCoordinateSystem, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceLocationCoordinateSystem", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiDistrictSourceState converts OAPI to gNMI.
func EncodeToGnmiDistrictSourceState(
	jsonObj *DistrictSourceState, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: error string
	if jsonObj.Error != nil { // Optional leaf

		paramsError := make([]string, len(params))
		copy(paramsError, params)
		stringValError := fmt.Sprintf("%v", *jsonObj.Error)

		paramsError = append(paramsError, stringValError)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceStateError", paramsError...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/error"), paramsError...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: error-since string
	if jsonObj.ErrorSince != nil { // Optional leaf

		paramsErrorSince := make([]string, len(params))
		copy(paramsErrorSince, params)
		stringValErrorSince := fmt.Sprintf("%v", *jsonObj.ErrorSince)

		paramsErrorSince = append(paramsErrorSince, stringValErrorSince)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceStateErrorSince", paramsErrorSince...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/error-since"), paramsErrorSince...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: status string
	if jsonObj.Status != nil { // Optional leaf

		paramsStatus := make([]string, len(params))
		copy(paramsStatus, params)
		stringValStatus := fmt.Sprintf("%v", *jsonObj.Status)

		paramsStatus = append(paramsStatus, stringValStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceStateStatus", paramsStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/status"), paramsStatus...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DistrictSourceState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictSourceVideo converts OAPI to gNMI.
func EncodeToGnmiDistrictSourceVideo(
	jsonObj *DistrictSourceVideo, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: path string
	_, unchangedPath := unchangedAttrs["path"]
	if !unchangedPath { // Mandatory leaf

		paramsPath := make([]string, len(params))
		copy(paramsPath, params)
		stringValPath := fmt.Sprintf("%v", jsonObj.Path)
		if stringValPath == "" {
			return nil, liberrors.NewInvalid("mandatory field 'path' of 'DistrictSourceVideo' must be provided or added to 'unchanged'")
		}
		paramsPath = append(paramsPath, stringValPath)
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceVideoPath", paramsPath...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/path"), paramsPath...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: source-type string
	_, unchangedSourceType := unchangedAttrs["source-type"]
	if !unchangedSourceType { // Mandatory leaf

		paramsSourceType := make([]string, len(params))
		copy(paramsSourceType, params)
		paramsSourceType = append(paramsSourceType, (string)(jsonObj.SourceType))
		mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceVideoSourceType", paramsSourceType...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/source-type"), paramsSourceType...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DistrictSourceVideo", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDistrictSourceVideoSourceType converts OAPI to gNMI.
func EncodeToGnmiDistrictSourceVideoSourceType(
	jsonObj *DistrictSourceVideoSourceType, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "DistrictSourceVideoSourceType", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

//Ignoring LeafRefOption

//Ignoring LeafRefOptions

// EncodeToGnmiTrafficClassification converts OAPI to gNMI.
func EncodeToGnmiTrafficClassification(
	jsonObj *TrafficClassification, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: classification-application TrafficClassificationClassificationApplication
	if jsonObj.ClassificationApplication != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficClassificationClassificationApplication(
			jsonObj.ClassificationApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "classification-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: detection-application TrafficClassificationDetectionApplication
	if jsonObj.DetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficClassificationDetectionApplication(
			jsonObj.DetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: district TrafficClassificationDistrictList
	if jsonObj.District != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficClassificationDistrictList(
			jsonObj.District, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "district"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassification", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationClassificationApplication converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationClassificationApplication(
	jsonObj *TrafficClassificationClassificationApplication, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state TrafficClassificationClassificationApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficClassificationClassificationApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassificationClassificationApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationClassificationApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationClassificationApplicationDevice(
	jsonObj *TrafficClassificationClassificationApplicationDevice, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficClassificationClassificationApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationClassificationApplicationPrecision(
	jsonObj *TrafficClassificationClassificationApplicationPrecision, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficClassificationClassificationApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationClassificationApplicationModelState(
	jsonObj *TrafficClassificationClassificationApplicationModelState, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationClassificationApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassificationClassificationApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationDetectionApplication(
	jsonObj *TrafficClassificationDetectionApplication, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state TrafficClassificationDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficClassificationDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassificationDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationDetectionApplicationDevice(
	jsonObj *TrafficClassificationDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationDetectionApplicationPrecision(
	jsonObj *TrafficClassificationDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationDetectionApplicationModelState(
	jsonObj *TrafficClassificationDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassificationDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDistrict converts OAPI to gNMI.
func EncodeToGnmiTrafficClassificationDistrict(
	jsonObj *TrafficClassificationDistrict, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: district-ref ListKey
	_, unchangedDistrictRef := unchangedAttrs["district-ref"]
	if !unchangedDistrictRef { // Mandatory leaf

		paramsDistrictRef := make([]string, len(params))
		copy(paramsDistrictRef, params)
		stringValDistrictRef := fmt.Sprintf("%v", jsonObj.DistrictRef)

		paramsDistrictRef = append(paramsDistrictRef, stringValDistrictRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDistrictDistrictRef", paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/district-ref"), paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDistrictEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassificationDistrictStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassificationDistrict", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassificationDistrictList converts OAPI List to gNMI List.
func EncodeToGnmiTrafficClassificationDistrictList(
	jsonObj *TrafficClassificationDistrictList, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiTrafficClassificationDistrict(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiTrafficMonitoring converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoring(
	jsonObj *TrafficMonitoring, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: district TrafficMonitoringDistrictList
	if jsonObj.District != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficMonitoringDistrictList(
			jsonObj.District, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "district"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: person-vehicle-bike-detection-application TrafficMonitoringPersonVehicleBikeDetectionApplication
	if jsonObj.PersonVehicleBikeDetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplication(
			jsonObj.PersonVehicleBikeDetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "person-vehicle-bike-detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficMonitoringDistrict converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoringDistrict(
	jsonObj *TrafficMonitoringDistrict, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: district-ref ListKey
	_, unchangedDistrictRef := unchangedAttrs["district-ref"]
	if !unchangedDistrictRef { // Mandatory leaf

		paramsDistrictRef := make([]string, len(params))
		copy(paramsDistrictRef, params)
		stringValDistrictRef := fmt.Sprintf("%v", jsonObj.DistrictRef)

		paramsDistrictRef = append(paramsDistrictRef, stringValDistrictRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringDistrictDistrictRef", paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/district-ref"), paramsDistrictRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringDistrictEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringDistrictStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficMonitoringDistrict", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficMonitoringDistrictList converts OAPI List to gNMI List.
func EncodeToGnmiTrafficMonitoringDistrictList(
	jsonObj *TrafficMonitoringDistrictList, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiTrafficMonitoringDistrict(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplication(
	jsonObj *TrafficMonitoringPersonVehicleBikeDetectionApplication, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state TrafficMonitoringPersonVehicleBikeDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficMonitoringPersonVehicleBikeDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationDevice(
	jsonObj *TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision(
	jsonObj *TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiTrafficMonitoringPersonVehicleBikeDetectionApplicationModelState(
	jsonObj *TrafficMonitoringPersonVehicleBikeDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficMonitoringPersonVehicleBikeDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiCityId converts OAPI to gNMI.
func EncodeToGnmiCityId(
	jsonObj *CityId, needKey bool, removeIndex bool, enterpriseId CityId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = CityId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "CityId", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

//Ignoring RequestBodyCollisionDetection

//Ignoring RequestBodyCollisionDetectionDetectionApplication

//Ignoring RequestBodyCollisionDetectionDistrict

//Ignoring RequestBodyDistrict

//Ignoring RequestBodyDistrictLocation

//Ignoring RequestBodyDistrictSource

//Ignoring RequestBodyDistrictSourceLocation

//Ignoring RequestBodyDistrictSourceVideo

//Ignoring RequestBodyTrafficClassification

//Ignoring RequestBodyTrafficClassificationClassificationApplication

//Ignoring RequestBodyTrafficClassificationDetectionApplication

//Ignoring RequestBodyTrafficClassificationDistrict

//Ignoring RequestBodyTrafficMonitoring

//Ignoring RequestBodyTrafficMonitoringDistrict

//Ignoring RequestBodyTrafficMonitoringPersonVehicleBikeDetectionApplication

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating param-types

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating request-bodies

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating additional-properties
// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating additional-properties
