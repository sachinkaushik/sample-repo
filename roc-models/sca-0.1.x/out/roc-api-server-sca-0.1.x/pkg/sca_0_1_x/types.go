// Package sca_0_1_x provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/intel-innersource/frameworks.edge.one-intel-edge.maestro-app.roc.rocaas-tools/rocaas-cli version (devel) DO NOT EDIT.
package sca_0_1_x

import (
	"encoding/json"
	"fmt"
)

// Defines values for CollisionDetectionDetectionApplicationDevice.
const (
	CollisionDetectionDetectionApplicationDeviceCpu CollisionDetectionDetectionApplicationDevice = "cpu"
	CollisionDetectionDetectionApplicationDeviceGpu CollisionDetectionDetectionApplicationDevice = "gpu"
	CollisionDetectionDetectionApplicationDeviceVpu CollisionDetectionDetectionApplicationDevice = "vpu"
)

// Defines values for CollisionDetectionDetectionApplicationPrecision.
const (
	CollisionDetectionDetectionApplicationPrecisionFp16 CollisionDetectionDetectionApplicationPrecision = "fp16"
	CollisionDetectionDetectionApplicationPrecisionFp32 CollisionDetectionDetectionApplicationPrecision = "fp32"
	CollisionDetectionDetectionApplicationPrecisionFp8  CollisionDetectionDetectionApplicationPrecision = "fp8"
)

// Defines values for DistrictLocationCoordinateSystem.
const (
	DistrictLocationCoordinateSystemGridBottomLeft DistrictLocationCoordinateSystem = "grid-bottom-left"
	DistrictLocationCoordinateSystemGridTopLeft    DistrictLocationCoordinateSystem = "grid-top-left"
	DistrictLocationCoordinateSystemLatLong        DistrictLocationCoordinateSystem = "lat-long"
)

// Defines values for DistrictSourceLocationCoordinateSystem.
const (
	DistrictSourceLocationCoordinateSystemGridBottomLeft DistrictSourceLocationCoordinateSystem = "grid-bottom-left"
	DistrictSourceLocationCoordinateSystemGridTopLeft    DistrictSourceLocationCoordinateSystem = "grid-top-left"
	DistrictSourceLocationCoordinateSystemLatLong        DistrictSourceLocationCoordinateSystem = "lat-long"
)

// Defines values for DistrictSourceVideoSourceType.
const (
	Device DistrictSourceVideoSourceType = "device"
	File   DistrictSourceVideoSourceType = "file"
	Sample DistrictSourceVideoSourceType = "sample"
	Stream DistrictSourceVideoSourceType = "stream"
)

// Defines values for TrafficClassificationClassificationApplicationDevice.
const (
	TrafficClassificationClassificationApplicationDeviceCpu TrafficClassificationClassificationApplicationDevice = "cpu"
	TrafficClassificationClassificationApplicationDeviceGpu TrafficClassificationClassificationApplicationDevice = "gpu"
	TrafficClassificationClassificationApplicationDeviceVpu TrafficClassificationClassificationApplicationDevice = "vpu"
)

// Defines values for TrafficClassificationClassificationApplicationPrecision.
const (
	TrafficClassificationClassificationApplicationPrecisionFp16 TrafficClassificationClassificationApplicationPrecision = "fp16"
	TrafficClassificationClassificationApplicationPrecisionFp32 TrafficClassificationClassificationApplicationPrecision = "fp32"
	TrafficClassificationClassificationApplicationPrecisionFp8  TrafficClassificationClassificationApplicationPrecision = "fp8"
)

// Defines values for TrafficClassificationDetectionApplicationDevice.
const (
	TrafficClassificationDetectionApplicationDeviceCpu TrafficClassificationDetectionApplicationDevice = "cpu"
	TrafficClassificationDetectionApplicationDeviceGpu TrafficClassificationDetectionApplicationDevice = "gpu"
	TrafficClassificationDetectionApplicationDeviceVpu TrafficClassificationDetectionApplicationDevice = "vpu"
)

// Defines values for TrafficClassificationDetectionApplicationPrecision.
const (
	TrafficClassificationDetectionApplicationPrecisionFp16 TrafficClassificationDetectionApplicationPrecision = "fp16"
	TrafficClassificationDetectionApplicationPrecisionFp32 TrafficClassificationDetectionApplicationPrecision = "fp32"
	TrafficClassificationDetectionApplicationPrecisionFp8  TrafficClassificationDetectionApplicationPrecision = "fp8"
)

// Defines values for TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice.
const (
	TrafficMonitoringPersonVehicleBikeDetectionApplicationDeviceCpu TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice = "cpu"
	TrafficMonitoringPersonVehicleBikeDetectionApplicationDeviceGpu TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice = "gpu"
	TrafficMonitoringPersonVehicleBikeDetectionApplicationDeviceVpu TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice = "vpu"
)

// Defines values for TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision.
const (
	TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecisionFp16 TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision = "fp16"
	TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecisionFp32 TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision = "fp32"
	TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecisionFp8  TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision = "fp8"
)

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// both the additional property 'unchanged' and the 'city-id'
type AdditionalPropertiesUnchTarget struct {
	// an override of the city-id (target)
	CityId *string `json:"city-id,omitempty"`

	// A comma seperated list of unchanged mandatory attribute names
	Unchanged *string `json:"unchanged,omitempty"`
}

// Optionally specify a city-id other than the default (only on PATCH method)
type AdditionalPropertyCityId struct {
	// an override of the city-id (target)
	CityId *string `json:"city-id,omitempty"`
}

// To optionally omit 'required' properties, add them to 'unchanged' list
type AdditionalPropertyUnchanged struct {
	// A comma seperated list of unchanged mandatory attribute names
	Unchanged *string `json:"unchanged,omitempty"`
}

// Configure Application to count objects in shelf
type CollisionDetection struct {
	// mark the default source
	Default *string `json:"default,omitempty"`

	// configuration of vehicle Detection
	DetectionApplication *CollisionDetectionDetectionApplication `json:"detection-application,omitempty"`

	// a list of references to sources (list)
	District *CollisionDetectionDistrictList `json:"district,omitempty"`

	// Pipeline enabled
	Enable               bool                                      `json:"enable"`
	AdditionalProperties map[string]AdditionalPropertiesUnchTarget `json:"-"`
}

// configuration of vehicle Detection
type CollisionDetectionDetectionApplication struct {
	// Choice of node device
	Device CollisionDetectionDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *CollisionDetectionDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            CollisionDetectionDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged          `json:"-"`
}

// Choice of node device
type CollisionDetectionDetectionApplicationDevice string

// Choice of node device
type CollisionDetectionDetectionApplicationPrecision string

// read only values about the models state
type CollisionDetectionDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// a list of references to sources (single)
type CollisionDetectionDistrict struct {
	// reference to a district
	DistrictRef ListKey `json:"district-ref"`

	// district sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type CollisionDetectionDistrictList = []CollisionDetectionDistrict

// district is a subsection of a city (single)
type District struct {
	// long description field
	Description *string `json:"description,omitempty"`

	// display name to use in GUI or CLI
	DisplayName *string `json:"display-name,omitempty"`

	// An identifier for the district
	DistrictId ListKey `json:"district-id"`

	// a URL to an image file (e.g. SVG, PNG). Optional
	Image *string `json:"image,omitempty"`

	// physical location in grid or latitude and longitude
	Location *DistrictLocation `json:"location,omitempty"`

	// The list of cameras (list)
	Source               *DistrictSourceList                 `json:"source,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyCityId `json:"-"`
}

// district is a subsection of a city (list)
type DistrictList = []District

// physical location in grid or latitude and longitude
type DistrictLocation struct {
	// choice of coordinate system
	CoordinateSystem DistrictLocationCoordinateSystem `json:"coordinate-system"`

	// rotation in dgrees the X-Y plane clockwise from the 3 o'clock position
	OrientationX *int64 `json:"orientation-x,omitempty"`

	// The X position in grid or longitude by 10e-7
	X int64 `json:"x"`

	// The Y position in grid or latitude by 10e-7
	Y int64 `json:"y"`

	// The Z position in grid or elevation in centimetres (optional)
	Z                    *int64                                 `json:"z,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// choice of coordinate system
type DistrictLocationCoordinateSystem string

// The list of cameras (single)
type DistrictSource struct {
	// long description field
	Description *string `json:"description,omitempty"`

	// display name to use in GUI or CLI
	DisplayName *string `json:"display-name,omitempty"`

	// a URL to an image file (e.g. SVG, PNG). Optional
	Image *string `json:"image,omitempty"`

	// physical location in grid or latitude and longitude
	Location *DistrictSourceLocation `json:"location,omitempty"`

	// the name of the inference source
	SourceId ListKey `json:"source-id"`

	// read only attributes of the source - populated by adapter from analytics engine
	State *DistrictSourceState `json:"state,omitempty"`

	// attributes related to video stream
	Video *DistrictSourceVideo `json:"video,omitempty"`
}

// The list of cameras (list)
type DistrictSourceList = []DistrictSource

// physical location in grid or latitude and longitude
type DistrictSourceLocation struct {
	// choice of coordinate system
	CoordinateSystem DistrictSourceLocationCoordinateSystem `json:"coordinate-system"`

	// rotation in dgrees the X-Y plane clockwise from the 3 o'clock position
	OrientationX *int64 `json:"orientation-x,omitempty"`

	// The X position in grid or longitude by 10e-7
	X int64 `json:"x"`

	// The Y position in grid or latitude by 10e-7
	Y int64 `json:"y"`

	// The Z position in grid or elevation in centimetres (optional)
	Z                    *int64                                 `json:"z,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// choice of coordinate system
type DistrictSourceLocationCoordinateSystem string

// read only attributes of the source - populated by adapter from analytics engine
type DistrictSourceState struct {
	// description of error if present
	Error *string `json:"error,omitempty"`

	// date and time error last updated
	ErrorSince *string `json:"error-since,omitempty"`

	// status of the source
	Status *string `json:"status,omitempty"`
}

// attributes related to video stream
type DistrictSourceVideo struct {
	// the path to the inference source
	Path string `json:"path"`

	// Source type
	SourceType           DistrictSourceVideoSourceType          `json:"source-type"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// Source type
type DistrictSourceVideoSourceType string

// single label/value of the leafref option
type LeafRefOption struct {
	// label of the leafref option
	Label *string `json:"label,omitempty"`

	// value of the leafref option
	Value *string `json:"value,omitempty"`
}

// List of label/value of leafref options
type LeafRefOptions = []LeafRefOption

// Configure the Application to classify traffic
type TrafficClassification struct {
	// configuration of traffic classification
	ClassificationApplication *TrafficClassificationClassificationApplication `json:"classification-application,omitempty"`

	// mark the default source
	Default *string `json:"default,omitempty"`

	// configuration of vehicle detection
	DetectionApplication *TrafficClassificationDetectionApplication `json:"detection-application,omitempty"`

	// a list of references to sources (list)
	District *TrafficClassificationDistrictList `json:"district,omitempty"`

	// Pipeline enabled
	Enable               bool                                      `json:"enable"`
	AdditionalProperties map[string]AdditionalPropertiesUnchTarget `json:"-"`
}

// configuration of traffic classification
type TrafficClassificationClassificationApplication struct {
	// Choice of node device
	Device TrafficClassificationClassificationApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *TrafficClassificationClassificationApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            TrafficClassificationClassificationApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged                  `json:"-"`
}

// Choice of node device
type TrafficClassificationClassificationApplicationDevice string

// Choice of node device
type TrafficClassificationClassificationApplicationPrecision string

// read only values about the models state
type TrafficClassificationClassificationApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// configuration of vehicle detection
type TrafficClassificationDetectionApplication struct {
	// Choice of node device
	Device TrafficClassificationDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *TrafficClassificationDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            TrafficClassificationDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged             `json:"-"`
}

// Choice of node device
type TrafficClassificationDetectionApplicationDevice string

// Choice of node device
type TrafficClassificationDetectionApplicationPrecision string

// read only values about the models state
type TrafficClassificationDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// a list of references to sources (single)
type TrafficClassificationDistrict struct {
	// reference to a district
	DistrictRef ListKey `json:"district-ref"`

	// district sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type TrafficClassificationDistrictList = []TrafficClassificationDistrict

// Configure of Application to display count of persons, vehicles, and bicycles
type TrafficMonitoring struct {
	// mark the default source
	Default *string `json:"default,omitempty"`

	// a list of references to sources (list)
	District *TrafficMonitoringDistrictList `json:"district,omitempty"`

	// Pipeline enabled
	Enable bool `json:"enable"`

	// configuration Person, Vehicle, and Bike detection
	PersonVehicleBikeDetectionApplication *TrafficMonitoringPersonVehicleBikeDetectionApplication `json:"person-vehicle-bike-detection-application,omitempty"`
	AdditionalProperties                  map[string]AdditionalPropertiesUnchTarget               `json:"-"`
}

// a list of references to sources (single)
type TrafficMonitoringDistrict struct {
	// reference to a district
	DistrictRef ListKey `json:"district-ref"`

	// district sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type TrafficMonitoringDistrictList = []TrafficMonitoringDistrict

// configuration Person, Vehicle, and Bike detection
type TrafficMonitoringPersonVehicleBikeDetectionApplication struct {
	// Choice of node device
	Device TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *TrafficMonitoringPersonVehicleBikeDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged                          `json:"-"`
}

// Choice of node device
type TrafficMonitoringPersonVehicleBikeDetectionApplicationDevice string

// Choice of node device
type TrafficMonitoringPersonVehicleBikeDetectionApplicationPrecision string

// read only values about the models state
type TrafficMonitoringPersonVehicleBikeDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// city-id (target in onos-config)
type CityId string

// Configure Application to count objects in shelf
type RequestBodyCollisionDetection = CollisionDetection

// configuration of vehicle Detection
type RequestBodyCollisionDetectionDetectionApplication = CollisionDetectionDetectionApplication

// a list of references to sources (single)
type RequestBodyCollisionDetectionDistrict = CollisionDetectionDistrict

// district is a subsection of a city (single)
type RequestBodyDistrict = District

// physical location in grid or latitude and longitude
type RequestBodyDistrictLocation = DistrictLocation

// The list of cameras (single)
type RequestBodyDistrictSource = DistrictSource

// physical location in grid or latitude and longitude
type RequestBodyDistrictSourceLocation = DistrictSourceLocation

// attributes related to video stream
type RequestBodyDistrictSourceVideo = DistrictSourceVideo

// Configure the Application to classify traffic
type RequestBodyTrafficClassification = TrafficClassification

// configuration of traffic classification
type RequestBodyTrafficClassificationClassificationApplication = TrafficClassificationClassificationApplication

// configuration of vehicle detection
type RequestBodyTrafficClassificationDetectionApplication = TrafficClassificationDetectionApplication

// a list of references to sources (single)
type RequestBodyTrafficClassificationDistrict = TrafficClassificationDistrict

// Configure of Application to display count of persons, vehicles, and bicycles
type RequestBodyTrafficMonitoring = TrafficMonitoring

// a list of references to sources (single)
type RequestBodyTrafficMonitoringDistrict = TrafficMonitoringDistrict

// configuration Person, Vehicle, and Bike detection
type RequestBodyTrafficMonitoringPersonVehicleBikeDetectionApplication = TrafficMonitoringPersonVehicleBikeDetectionApplication

// ListKey a type for list keys
type ListKey string

// TargetName defines model for TargetName.
type TargetName struct {
	Name *string `json:"name,omitempty"`
}

// TargetsNames defines model for TargetsNames.
type TargetsNames []TargetName

// PostCollisionDetectionJSONRequestBody defines body for PostCollisionDetection for application/json ContentType.
type PostCollisionDetectionJSONRequestBody = RequestBodyCollisionDetection

// PostCollisionDetectionDetectionApplicationJSONRequestBody defines body for PostCollisionDetectionDetectionApplication for application/json ContentType.
type PostCollisionDetectionDetectionApplicationJSONRequestBody = RequestBodyCollisionDetectionDetectionApplication

// PostCollisionDetectionDistrictJSONRequestBody defines body for PostCollisionDetectionDistrict for application/json ContentType.
type PostCollisionDetectionDistrictJSONRequestBody = RequestBodyCollisionDetectionDistrict

// PostDistrictJSONRequestBody defines body for PostDistrict for application/json ContentType.
type PostDistrictJSONRequestBody = RequestBodyDistrict

// PostDistrictLocationJSONRequestBody defines body for PostDistrictLocation for application/json ContentType.
type PostDistrictLocationJSONRequestBody = RequestBodyDistrictLocation

// PostDistrictSourceJSONRequestBody defines body for PostDistrictSource for application/json ContentType.
type PostDistrictSourceJSONRequestBody = RequestBodyDistrictSource

// PostDistrictSourceLocationJSONRequestBody defines body for PostDistrictSourceLocation for application/json ContentType.
type PostDistrictSourceLocationJSONRequestBody = RequestBodyDistrictSourceLocation

// PostDistrictSourceVideoJSONRequestBody defines body for PostDistrictSourceVideo for application/json ContentType.
type PostDistrictSourceVideoJSONRequestBody = RequestBodyDistrictSourceVideo

// PostTrafficClassificationJSONRequestBody defines body for PostTrafficClassification for application/json ContentType.
type PostTrafficClassificationJSONRequestBody = RequestBodyTrafficClassification

// PostTrafficClassificationClassificationApplicationJSONRequestBody defines body for PostTrafficClassificationClassificationApplication for application/json ContentType.
type PostTrafficClassificationClassificationApplicationJSONRequestBody = RequestBodyTrafficClassificationClassificationApplication

// PostTrafficClassificationDetectionApplicationJSONRequestBody defines body for PostTrafficClassificationDetectionApplication for application/json ContentType.
type PostTrafficClassificationDetectionApplicationJSONRequestBody = RequestBodyTrafficClassificationDetectionApplication

// PostTrafficClassificationDistrictJSONRequestBody defines body for PostTrafficClassificationDistrict for application/json ContentType.
type PostTrafficClassificationDistrictJSONRequestBody = RequestBodyTrafficClassificationDistrict

// PostTrafficMonitoringJSONRequestBody defines body for PostTrafficMonitoring for application/json ContentType.
type PostTrafficMonitoringJSONRequestBody = RequestBodyTrafficMonitoring

// PostTrafficMonitoringDistrictJSONRequestBody defines body for PostTrafficMonitoringDistrict for application/json ContentType.
type PostTrafficMonitoringDistrictJSONRequestBody = RequestBodyTrafficMonitoringDistrict

// PostTrafficMonitoringPersonVehicleBikeDetectionApplicationJSONRequestBody defines body for PostTrafficMonitoringPersonVehicleBikeDetectionApplication for application/json ContentType.
type PostTrafficMonitoringPersonVehicleBikeDetectionApplicationJSONRequestBody = RequestBodyTrafficMonitoringPersonVehicleBikeDetectionApplication

// Getter for additional properties for CollisionDetection. Returns the specified
// element and whether it was found
func (a CollisionDetection) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CollisionDetection
func (a *CollisionDetection) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CollisionDetection to handle AdditionalProperties
func (a *CollisionDetection) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["detection-application"]; found {
		err = json.Unmarshal(raw, &a.DetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'detection-application': %w", err)
		}
		delete(object, "detection-application")
	}

	if raw, found := object["district"]; found {
		err = json.Unmarshal(raw, &a.District)
		if err != nil {
			return fmt.Errorf("error reading 'district': %w", err)
		}
		delete(object, "district")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CollisionDetection to handle AdditionalProperties
func (a CollisionDetection) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	if a.DetectionApplication != nil {
		object["detection-application"], err = json.Marshal(a.DetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detection-application': %w", err)
		}
	}

	if a.District != nil {
		object["district"], err = json.Marshal(a.District)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'district': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CollisionDetectionDetectionApplication. Returns the specified
// element and whether it was found
func (a CollisionDetectionDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CollisionDetectionDetectionApplication
func (a *CollisionDetectionDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CollisionDetectionDetectionApplication to handle AdditionalProperties
func (a *CollisionDetectionDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CollisionDetectionDetectionApplication to handle AdditionalProperties
func (a CollisionDetectionDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CollisionDetectionDistrict. Returns the specified
// element and whether it was found
func (a CollisionDetectionDistrict) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CollisionDetectionDistrict
func (a *CollisionDetectionDistrict) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CollisionDetectionDistrict to handle AdditionalProperties
func (a *CollisionDetectionDistrict) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["district-ref"]; found {
		err = json.Unmarshal(raw, &a.DistrictRef)
		if err != nil {
			return fmt.Errorf("error reading 'district-ref': %w", err)
		}
		delete(object, "district-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CollisionDetectionDistrict to handle AdditionalProperties
func (a CollisionDetectionDistrict) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["district-ref"], err = json.Marshal(a.DistrictRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'district-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for District. Returns the specified
// element and whether it was found
func (a District) Get(fieldName string) (value AdditionalPropertyCityId, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for District
func (a *District) Set(fieldName string, value AdditionalPropertyCityId) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyCityId)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for District to handle AdditionalProperties
func (a *District) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["display-name"]; found {
		err = json.Unmarshal(raw, &a.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display-name': %w", err)
		}
		delete(object, "display-name")
	}

	if raw, found := object["district-id"]; found {
		err = json.Unmarshal(raw, &a.DistrictId)
		if err != nil {
			return fmt.Errorf("error reading 'district-id': %w", err)
		}
		delete(object, "district-id")
	}

	if raw, found := object["image"]; found {
		err = json.Unmarshal(raw, &a.Image)
		if err != nil {
			return fmt.Errorf("error reading 'image': %w", err)
		}
		delete(object, "image")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyCityId)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyCityId
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for District to handle AdditionalProperties
func (a District) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DisplayName != nil {
		object["display-name"], err = json.Marshal(a.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display-name': %w", err)
		}
	}

	object["district-id"], err = json.Marshal(a.DistrictId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'district-id': %w", err)
	}

	if a.Image != nil {
		object["image"], err = json.Marshal(a.Image)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'image': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DistrictLocation. Returns the specified
// element and whether it was found
func (a DistrictLocation) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DistrictLocation
func (a *DistrictLocation) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DistrictLocation to handle AdditionalProperties
func (a *DistrictLocation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["coordinate-system"]; found {
		err = json.Unmarshal(raw, &a.CoordinateSystem)
		if err != nil {
			return fmt.Errorf("error reading 'coordinate-system': %w", err)
		}
		delete(object, "coordinate-system")
	}

	if raw, found := object["orientation-x"]; found {
		err = json.Unmarshal(raw, &a.OrientationX)
		if err != nil {
			return fmt.Errorf("error reading 'orientation-x': %w", err)
		}
		delete(object, "orientation-x")
	}

	if raw, found := object["x"]; found {
		err = json.Unmarshal(raw, &a.X)
		if err != nil {
			return fmt.Errorf("error reading 'x': %w", err)
		}
		delete(object, "x")
	}

	if raw, found := object["y"]; found {
		err = json.Unmarshal(raw, &a.Y)
		if err != nil {
			return fmt.Errorf("error reading 'y': %w", err)
		}
		delete(object, "y")
	}

	if raw, found := object["z"]; found {
		err = json.Unmarshal(raw, &a.Z)
		if err != nil {
			return fmt.Errorf("error reading 'z': %w", err)
		}
		delete(object, "z")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DistrictLocation to handle AdditionalProperties
func (a DistrictLocation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["coordinate-system"], err = json.Marshal(a.CoordinateSystem)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'coordinate-system': %w", err)
	}

	if a.OrientationX != nil {
		object["orientation-x"], err = json.Marshal(a.OrientationX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'orientation-x': %w", err)
		}
	}

	object["x"], err = json.Marshal(a.X)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'x': %w", err)
	}

	object["y"], err = json.Marshal(a.Y)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'y': %w", err)
	}

	if a.Z != nil {
		object["z"], err = json.Marshal(a.Z)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DistrictSourceLocation. Returns the specified
// element and whether it was found
func (a DistrictSourceLocation) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DistrictSourceLocation
func (a *DistrictSourceLocation) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DistrictSourceLocation to handle AdditionalProperties
func (a *DistrictSourceLocation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["coordinate-system"]; found {
		err = json.Unmarshal(raw, &a.CoordinateSystem)
		if err != nil {
			return fmt.Errorf("error reading 'coordinate-system': %w", err)
		}
		delete(object, "coordinate-system")
	}

	if raw, found := object["orientation-x"]; found {
		err = json.Unmarshal(raw, &a.OrientationX)
		if err != nil {
			return fmt.Errorf("error reading 'orientation-x': %w", err)
		}
		delete(object, "orientation-x")
	}

	if raw, found := object["x"]; found {
		err = json.Unmarshal(raw, &a.X)
		if err != nil {
			return fmt.Errorf("error reading 'x': %w", err)
		}
		delete(object, "x")
	}

	if raw, found := object["y"]; found {
		err = json.Unmarshal(raw, &a.Y)
		if err != nil {
			return fmt.Errorf("error reading 'y': %w", err)
		}
		delete(object, "y")
	}

	if raw, found := object["z"]; found {
		err = json.Unmarshal(raw, &a.Z)
		if err != nil {
			return fmt.Errorf("error reading 'z': %w", err)
		}
		delete(object, "z")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DistrictSourceLocation to handle AdditionalProperties
func (a DistrictSourceLocation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["coordinate-system"], err = json.Marshal(a.CoordinateSystem)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'coordinate-system': %w", err)
	}

	if a.OrientationX != nil {
		object["orientation-x"], err = json.Marshal(a.OrientationX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'orientation-x': %w", err)
		}
	}

	object["x"], err = json.Marshal(a.X)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'x': %w", err)
	}

	object["y"], err = json.Marshal(a.Y)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'y': %w", err)
	}

	if a.Z != nil {
		object["z"], err = json.Marshal(a.Z)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DistrictSourceVideo. Returns the specified
// element and whether it was found
func (a DistrictSourceVideo) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DistrictSourceVideo
func (a *DistrictSourceVideo) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DistrictSourceVideo to handle AdditionalProperties
func (a *DistrictSourceVideo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["source-type"]; found {
		err = json.Unmarshal(raw, &a.SourceType)
		if err != nil {
			return fmt.Errorf("error reading 'source-type': %w", err)
		}
		delete(object, "source-type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DistrictSourceVideo to handle AdditionalProperties
func (a DistrictSourceVideo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["path"], err = json.Marshal(a.Path)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'path': %w", err)
	}

	object["source-type"], err = json.Marshal(a.SourceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'source-type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficClassification. Returns the specified
// element and whether it was found
func (a TrafficClassification) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficClassification
func (a *TrafficClassification) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficClassification to handle AdditionalProperties
func (a *TrafficClassification) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["classification-application"]; found {
		err = json.Unmarshal(raw, &a.ClassificationApplication)
		if err != nil {
			return fmt.Errorf("error reading 'classification-application': %w", err)
		}
		delete(object, "classification-application")
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["detection-application"]; found {
		err = json.Unmarshal(raw, &a.DetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'detection-application': %w", err)
		}
		delete(object, "detection-application")
	}

	if raw, found := object["district"]; found {
		err = json.Unmarshal(raw, &a.District)
		if err != nil {
			return fmt.Errorf("error reading 'district': %w", err)
		}
		delete(object, "district")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficClassification to handle AdditionalProperties
func (a TrafficClassification) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ClassificationApplication != nil {
		object["classification-application"], err = json.Marshal(a.ClassificationApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'classification-application': %w", err)
		}
	}

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	if a.DetectionApplication != nil {
		object["detection-application"], err = json.Marshal(a.DetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detection-application': %w", err)
		}
	}

	if a.District != nil {
		object["district"], err = json.Marshal(a.District)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'district': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficClassificationClassificationApplication. Returns the specified
// element and whether it was found
func (a TrafficClassificationClassificationApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficClassificationClassificationApplication
func (a *TrafficClassificationClassificationApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficClassificationClassificationApplication to handle AdditionalProperties
func (a *TrafficClassificationClassificationApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficClassificationClassificationApplication to handle AdditionalProperties
func (a TrafficClassificationClassificationApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficClassificationDetectionApplication. Returns the specified
// element and whether it was found
func (a TrafficClassificationDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficClassificationDetectionApplication
func (a *TrafficClassificationDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficClassificationDetectionApplication to handle AdditionalProperties
func (a *TrafficClassificationDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficClassificationDetectionApplication to handle AdditionalProperties
func (a TrafficClassificationDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficClassificationDistrict. Returns the specified
// element and whether it was found
func (a TrafficClassificationDistrict) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficClassificationDistrict
func (a *TrafficClassificationDistrict) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficClassificationDistrict to handle AdditionalProperties
func (a *TrafficClassificationDistrict) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["district-ref"]; found {
		err = json.Unmarshal(raw, &a.DistrictRef)
		if err != nil {
			return fmt.Errorf("error reading 'district-ref': %w", err)
		}
		delete(object, "district-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficClassificationDistrict to handle AdditionalProperties
func (a TrafficClassificationDistrict) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["district-ref"], err = json.Marshal(a.DistrictRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'district-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficMonitoring. Returns the specified
// element and whether it was found
func (a TrafficMonitoring) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficMonitoring
func (a *TrafficMonitoring) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficMonitoring to handle AdditionalProperties
func (a *TrafficMonitoring) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["district"]; found {
		err = json.Unmarshal(raw, &a.District)
		if err != nil {
			return fmt.Errorf("error reading 'district': %w", err)
		}
		delete(object, "district")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if raw, found := object["person-vehicle-bike-detection-application"]; found {
		err = json.Unmarshal(raw, &a.PersonVehicleBikeDetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'person-vehicle-bike-detection-application': %w", err)
		}
		delete(object, "person-vehicle-bike-detection-application")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficMonitoring to handle AdditionalProperties
func (a TrafficMonitoring) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	if a.District != nil {
		object["district"], err = json.Marshal(a.District)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'district': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	if a.PersonVehicleBikeDetectionApplication != nil {
		object["person-vehicle-bike-detection-application"], err = json.Marshal(a.PersonVehicleBikeDetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'person-vehicle-bike-detection-application': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficMonitoringDistrict. Returns the specified
// element and whether it was found
func (a TrafficMonitoringDistrict) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficMonitoringDistrict
func (a *TrafficMonitoringDistrict) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficMonitoringDistrict to handle AdditionalProperties
func (a *TrafficMonitoringDistrict) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["district-ref"]; found {
		err = json.Unmarshal(raw, &a.DistrictRef)
		if err != nil {
			return fmt.Errorf("error reading 'district-ref': %w", err)
		}
		delete(object, "district-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficMonitoringDistrict to handle AdditionalProperties
func (a TrafficMonitoringDistrict) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["district-ref"], err = json.Marshal(a.DistrictRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'district-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficMonitoringPersonVehicleBikeDetectionApplication. Returns the specified
// element and whether it was found
func (a TrafficMonitoringPersonVehicleBikeDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficMonitoringPersonVehicleBikeDetectionApplication
func (a *TrafficMonitoringPersonVehicleBikeDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficMonitoringPersonVehicleBikeDetectionApplication to handle AdditionalProperties
func (a *TrafficMonitoringPersonVehicleBikeDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficMonitoringPersonVehicleBikeDetectionApplication to handle AdditionalProperties
func (a TrafficMonitoringPersonVehicleBikeDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
