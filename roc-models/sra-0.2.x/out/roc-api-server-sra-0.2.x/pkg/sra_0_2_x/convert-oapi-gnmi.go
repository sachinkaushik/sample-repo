// Package sra_0_2_x provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/intel-innersource/frameworks.edge.one-intel-edge.maestro-app.roc.rocaas-tools/rocaas-cli version (devel) DO NOT EDIT.
package sra_0_2_x

import (
	"fmt"
	"strings"

	externalRef0 "github.com/intel-innersource/frameworks.edge.one-intel-edge.springboard.reference-implementation.roc-models/models/sra-0.2.x/api"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	// Not generating constants
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	// Not generating constants
	// SPDX-FileCopyrightText: 2022-present Intel Corporation
	//
	// SPDX-License-Identifier: LicenseRef-Intel

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertiesUnchTarget

//Ignoring AdditionalPropertyStoreId

//Ignoring AdditionalPropertyUnchanged

//Ignoring LeafRefOption

//Ignoring LeafRefOptions

// EncodeToGnmiRetailArea converts OAPI to gNMI.
func EncodeToGnmiRetailArea(
	jsonObj *RetailArea, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: area-id ListKey
	_, unchangedAreaId := unchangedAttrs["area-id"]
	if !unchangedAreaId { // Mandatory leaf

		paramsAreaId := make([]string, len(params))
		copy(paramsAreaId, params)
		stringValAreaId := fmt.Sprintf("%v", jsonObj.AreaId)

		paramsAreaId = append(paramsAreaId, stringValAreaId)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaAreaId", paramsAreaId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/area-id"), paramsAreaId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: image string
	if jsonObj.Image != nil { // Optional leaf

		paramsImage := make([]string, len(params))
		copy(paramsImage, params)
		stringValImage := fmt.Sprintf("%v", *jsonObj.Image)

		paramsImage = append(paramsImage, stringValImage)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaImage", paramsImage...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/image"), paramsImage...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: location RetailAreaLocation
	if jsonObj.Location != nil { // Optional leaf

		update, err := EncodeToGnmiRetailAreaLocation(
			jsonObj.Location, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "location"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: source RetailAreaSourceList
	if jsonObj.Source != nil { // Optional leaf

		update, err := EncodeToGnmiRetailAreaSourceList(
			jsonObj.Source, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "source"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailArea", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaList converts OAPI List to gNMI List.
func EncodeToGnmiRetailAreaList(
	jsonObj *RetailAreaList, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiRetailArea(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiRetailAreaLocation converts OAPI to gNMI.
func EncodeToGnmiRetailAreaLocation(
	jsonObj *RetailAreaLocation, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: coordinate-system string
	_, unchangedCoordinateSystem := unchangedAttrs["coordinate-system"]
	if !unchangedCoordinateSystem { // Mandatory leaf

		paramsCoordinateSystem := make([]string, len(params))
		copy(paramsCoordinateSystem, params)
		paramsCoordinateSystem = append(paramsCoordinateSystem, (string)(jsonObj.CoordinateSystem))
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationCoordinateSystem", paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/coordinate-system"), paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: orientation-x int64
	if jsonObj.OrientationX != nil { // Optional leaf

		paramsOrientationX := make([]string, len(params))
		copy(paramsOrientationX, params)
		stringValOrientationX := fmt.Sprintf("%v", *jsonObj.OrientationX)

		paramsOrientationX = append(paramsOrientationX, stringValOrientationX)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationOrientationX", paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/orientation-x"), paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: x int64
	_, unchangedX := unchangedAttrs["x"]
	if !unchangedX { // Mandatory leaf

		paramsX := make([]string, len(params))
		copy(paramsX, params)
		stringValX := fmt.Sprintf("%v", jsonObj.X)

		paramsX = append(paramsX, stringValX)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationX", paramsX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/x"), paramsX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: y int64
	_, unchangedY := unchangedAttrs["y"]
	if !unchangedY { // Mandatory leaf

		paramsY := make([]string, len(params))
		copy(paramsY, params)
		stringValY := fmt.Sprintf("%v", jsonObj.Y)

		paramsY = append(paramsY, stringValY)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationY", paramsY...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/y"), paramsY...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: z int64
	if jsonObj.Z != nil { // Optional leaf

		paramsZ := make([]string, len(params))
		copy(paramsZ, params)
		stringValZ := fmt.Sprintf("%v", *jsonObj.Z)

		paramsZ = append(paramsZ, stringValZ)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationZ", paramsZ...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/z"), paramsZ...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailAreaLocation", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaLocationCoordinateSystem converts OAPI to gNMI.
func EncodeToGnmiRetailAreaLocationCoordinateSystem(
	jsonObj *RetailAreaLocationCoordinateSystem, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaLocationCoordinateSystem", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiRetailAreaSource converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSource(
	jsonObj *RetailAreaSource, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: image string
	if jsonObj.Image != nil { // Optional leaf

		paramsImage := make([]string, len(params))
		copy(paramsImage, params)
		stringValImage := fmt.Sprintf("%v", *jsonObj.Image)

		paramsImage = append(paramsImage, stringValImage)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceImage", paramsImage...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/image"), paramsImage...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: location RetailAreaSourceLocation
	if jsonObj.Location != nil { // Optional leaf

		update, err := EncodeToGnmiRetailAreaSourceLocation(
			jsonObj.Location, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "location"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: source-id ListKey
	_, unchangedSourceId := unchangedAttrs["source-id"]
	if !unchangedSourceId { // Mandatory leaf

		paramsSourceId := make([]string, len(params))
		copy(paramsSourceId, params)
		stringValSourceId := fmt.Sprintf("%v", jsonObj.SourceId)

		paramsSourceId = append(paramsSourceId, stringValSourceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceSourceId", paramsSourceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/source-id"), paramsSourceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: state RetailAreaSourceState
	if jsonObj.State != nil { // Optional leaf

		update, err := EncodeToGnmiRetailAreaSourceState(
			jsonObj.State, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: video RetailAreaSourceVideo
	if jsonObj.Video != nil { // Optional leaf

		update, err := EncodeToGnmiRetailAreaSourceVideo(
			jsonObj.Video, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "video"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailAreaSource", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaSourceList converts OAPI List to gNMI List.
func EncodeToGnmiRetailAreaSourceList(
	jsonObj *RetailAreaSourceList, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiRetailAreaSource(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiRetailAreaSourceLocation converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSourceLocation(
	jsonObj *RetailAreaSourceLocation, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: coordinate-system string
	_, unchangedCoordinateSystem := unchangedAttrs["coordinate-system"]
	if !unchangedCoordinateSystem { // Mandatory leaf

		paramsCoordinateSystem := make([]string, len(params))
		copy(paramsCoordinateSystem, params)
		paramsCoordinateSystem = append(paramsCoordinateSystem, (string)(jsonObj.CoordinateSystem))
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationCoordinateSystem", paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/coordinate-system"), paramsCoordinateSystem...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: orientation-x int64
	if jsonObj.OrientationX != nil { // Optional leaf

		paramsOrientationX := make([]string, len(params))
		copy(paramsOrientationX, params)
		stringValOrientationX := fmt.Sprintf("%v", *jsonObj.OrientationX)

		paramsOrientationX = append(paramsOrientationX, stringValOrientationX)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationOrientationX", paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/orientation-x"), paramsOrientationX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: x int64
	_, unchangedX := unchangedAttrs["x"]
	if !unchangedX { // Mandatory leaf

		paramsX := make([]string, len(params))
		copy(paramsX, params)
		stringValX := fmt.Sprintf("%v", jsonObj.X)

		paramsX = append(paramsX, stringValX)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationX", paramsX...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/x"), paramsX...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: y int64
	_, unchangedY := unchangedAttrs["y"]
	if !unchangedY { // Mandatory leaf

		paramsY := make([]string, len(params))
		copy(paramsY, params)
		stringValY := fmt.Sprintf("%v", jsonObj.Y)

		paramsY = append(paramsY, stringValY)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationY", paramsY...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/y"), paramsY...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: z int64
	if jsonObj.Z != nil { // Optional leaf

		paramsZ := make([]string, len(params))
		copy(paramsZ, params)
		stringValZ := fmt.Sprintf("%v", *jsonObj.Z)

		paramsZ = append(paramsZ, stringValZ)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationZ", paramsZ...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/z"), paramsZ...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailAreaSourceLocation", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaSourceLocationCoordinateSystem converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSourceLocationCoordinateSystem(
	jsonObj *RetailAreaSourceLocationCoordinateSystem, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceLocationCoordinateSystem", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiRetailAreaSourceState converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSourceState(
	jsonObj *RetailAreaSourceState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: error string
	if jsonObj.Error != nil { // Optional leaf

		paramsError := make([]string, len(params))
		copy(paramsError, params)
		stringValError := fmt.Sprintf("%v", *jsonObj.Error)

		paramsError = append(paramsError, stringValError)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceStateError", paramsError...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/error"), paramsError...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: error-since string
	if jsonObj.ErrorSince != nil { // Optional leaf

		paramsErrorSince := make([]string, len(params))
		copy(paramsErrorSince, params)
		stringValErrorSince := fmt.Sprintf("%v", *jsonObj.ErrorSince)

		paramsErrorSince = append(paramsErrorSince, stringValErrorSince)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceStateErrorSince", paramsErrorSince...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/error-since"), paramsErrorSince...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: status string
	if jsonObj.Status != nil { // Optional leaf

		paramsStatus := make([]string, len(params))
		copy(paramsStatus, params)
		stringValStatus := fmt.Sprintf("%v", *jsonObj.Status)

		paramsStatus = append(paramsStatus, stringValStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceStateStatus", paramsStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/status"), paramsStatus...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailAreaSourceState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaSourceVideo converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSourceVideo(
	jsonObj *RetailAreaSourceVideo, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: path string
	_, unchangedPath := unchangedAttrs["path"]
	if !unchangedPath { // Mandatory leaf

		paramsPath := make([]string, len(params))
		copy(paramsPath, params)
		stringValPath := fmt.Sprintf("%v", jsonObj.Path)
		if stringValPath == "" {
			return nil, liberrors.NewInvalid("mandatory field 'path' of 'RetailAreaSourceVideo' must be provided or added to 'unchanged'")
		}
		paramsPath = append(paramsPath, stringValPath)
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceVideoPath", paramsPath...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/path"), paramsPath...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: source-type string
	_, unchangedSourceType := unchangedAttrs["source-type"]
	if !unchangedSourceType { // Mandatory leaf

		paramsSourceType := make([]string, len(params))
		copy(paramsSourceType, params)
		paramsSourceType = append(paramsSourceType, (string)(jsonObj.SourceType))
		mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceVideoSourceType", paramsSourceType...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/source-type"), paramsSourceType...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RetailAreaSourceVideo", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRetailAreaSourceVideoSourceType converts OAPI to gNMI.
func EncodeToGnmiRetailAreaSourceVideoSourceType(
	jsonObj *RetailAreaSourceVideoSourceType, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "RetailAreaSourceVideoSourceType", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShelfMonitoring converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoring(
	jsonObj *ShelfMonitoring, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: object-detection-application ShelfMonitoringObjectDetectionApplication
	if jsonObj.ObjectDetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiShelfMonitoringObjectDetectionApplication(
			jsonObj.ObjectDetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "object-detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: retail-area ShelfMonitoringRetailAreaList
	if jsonObj.RetailArea != nil { // Optional leaf

		update, err := EncodeToGnmiShelfMonitoringRetailAreaList(
			jsonObj.RetailArea, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "retail-area"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShelfMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShelfMonitoringObjectDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoringObjectDetectionApplication(
	jsonObj *ShelfMonitoringObjectDetectionApplication, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state ShelfMonitoringObjectDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiShelfMonitoringObjectDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShelfMonitoringObjectDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShelfMonitoringObjectDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoringObjectDetectionApplicationDevice(
	jsonObj *ShelfMonitoringObjectDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShelfMonitoringObjectDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoringObjectDetectionApplicationPrecision(
	jsonObj *ShelfMonitoringObjectDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShelfMonitoringObjectDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoringObjectDetectionApplicationModelState(
	jsonObj *ShelfMonitoringObjectDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringObjectDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShelfMonitoringObjectDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShelfMonitoringRetailArea converts OAPI to gNMI.
func EncodeToGnmiShelfMonitoringRetailArea(
	jsonObj *ShelfMonitoringRetailArea, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: area-ref ListKey
	_, unchangedAreaRef := unchangedAttrs["area-ref"]
	if !unchangedAreaRef { // Mandatory leaf

		paramsAreaRef := make([]string, len(params))
		copy(paramsAreaRef, params)
		stringValAreaRef := fmt.Sprintf("%v", jsonObj.AreaRef)

		paramsAreaRef = append(paramsAreaRef, stringValAreaRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringRetailAreaAreaRef", paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/area-ref"), paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringRetailAreaEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShelfMonitoringRetailAreaStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShelfMonitoringRetailArea", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShelfMonitoringRetailAreaList converts OAPI List to gNMI List.
func EncodeToGnmiShelfMonitoringRetailAreaList(
	jsonObj *ShelfMonitoringRetailAreaList, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiShelfMonitoringRetailArea(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiShopperMonitoring converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoring(
	jsonObj *ShopperMonitoring, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: emotion-recognition-application ShopperMonitoringEmotionRecognitionApplication
	if jsonObj.EmotionRecognitionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringEmotionRecognitionApplication(
			jsonObj.EmotionRecognitionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "emotion-recognition-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: face-detection-application ShopperMonitoringFaceDetectionApplication
	if jsonObj.FaceDetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringFaceDetectionApplication(
			jsonObj.FaceDetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "face-detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: head-pose-detection-application ShopperMonitoringHeadPoseDetectionApplication
	if jsonObj.HeadPoseDetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringHeadPoseDetectionApplication(
			jsonObj.HeadPoseDetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "head-pose-detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: retail-area ShopperMonitoringRetailAreaList
	if jsonObj.RetailArea != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringRetailAreaList(
			jsonObj.RetailArea, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "retail-area"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringEmotionRecognitionApplication converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringEmotionRecognitionApplication(
	jsonObj *ShopperMonitoringEmotionRecognitionApplication, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state ShopperMonitoringEmotionRecognitionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringEmotionRecognitionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationDevice(
	jsonObj *ShopperMonitoringEmotionRecognitionApplicationDevice, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationPrecision(
	jsonObj *ShopperMonitoringEmotionRecognitionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringEmotionRecognitionApplicationModelState(
	jsonObj *ShopperMonitoringEmotionRecognitionApplicationModelState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringEmotionRecognitionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringEmotionRecognitionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringFaceDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringFaceDetectionApplication(
	jsonObj *ShopperMonitoringFaceDetectionApplication, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state ShopperMonitoringFaceDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringFaceDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringFaceDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringFaceDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringFaceDetectionApplicationDevice(
	jsonObj *ShopperMonitoringFaceDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringFaceDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringFaceDetectionApplicationPrecision(
	jsonObj *ShopperMonitoringFaceDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringFaceDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringFaceDetectionApplicationModelState(
	jsonObj *ShopperMonitoringFaceDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringFaceDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringFaceDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringHeadPoseDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringHeadPoseDetectionApplication(
	jsonObj *ShopperMonitoringHeadPoseDetectionApplication, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state ShopperMonitoringHeadPoseDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringHeadPoseDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationDevice(
	jsonObj *ShopperMonitoringHeadPoseDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationPrecision(
	jsonObj *ShopperMonitoringHeadPoseDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringHeadPoseDetectionApplicationModelState(
	jsonObj *ShopperMonitoringHeadPoseDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringHeadPoseDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringHeadPoseDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringRetailArea converts OAPI to gNMI.
func EncodeToGnmiShopperMonitoringRetailArea(
	jsonObj *ShopperMonitoringRetailArea, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: area-ref ListKey
	_, unchangedAreaRef := unchangedAttrs["area-ref"]
	if !unchangedAreaRef { // Mandatory leaf

		paramsAreaRef := make([]string, len(params))
		copy(paramsAreaRef, params)
		stringValAreaRef := fmt.Sprintf("%v", jsonObj.AreaRef)

		paramsAreaRef = append(paramsAreaRef, stringValAreaRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringRetailAreaAreaRef", paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/area-ref"), paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringRetailAreaEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "ShopperMonitoringRetailAreaStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ShopperMonitoringRetailArea", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiShopperMonitoringRetailAreaList converts OAPI List to gNMI List.
func EncodeToGnmiShopperMonitoringRetailAreaList(
	jsonObj *ShopperMonitoringRetailAreaList, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiShopperMonitoringRetailArea(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoring converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoring(
	jsonObj *StoreTrafficMonitoring, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default string
	if jsonObj.Default != nil { // Optional leaf

		paramsDefault := make([]string, len(params))
		copy(paramsDefault, params)
		stringValDefault := fmt.Sprintf("%v", *jsonObj.Default)

		paramsDefault = append(paramsDefault, stringValDefault)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringDefault", paramsDefault...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default"), paramsDefault...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	_, unchangedEnable := unchangedAttrs["enable"]
	if !unchangedEnable { // Mandatory leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: person-detection-application StoreTrafficMonitoringPersonDetectionApplication
	if jsonObj.PersonDetectionApplication != nil { // Optional leaf

		update, err := EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplication(
			jsonObj.PersonDetectionApplication, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "person-detection-application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: retail-area StoreTrafficMonitoringRetailAreaList
	if jsonObj.RetailArea != nil { // Optional leaf

		update, err := EncodeToGnmiStoreTrafficMonitoringRetailAreaList(
			jsonObj.RetailArea, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "retail-area"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "StoreTrafficMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplication converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplication(
	jsonObj *StoreTrafficMonitoringPersonDetectionApplication, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		paramsDevice = append(paramsDevice, (string)(jsonObj.Device))
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model string
	if jsonObj.Model != nil { // Optional leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", *jsonObj.Model)

		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: model-state StoreTrafficMonitoringPersonDetectionApplicationModelState
	if jsonObj.ModelState != nil { // Optional leaf

		update, err := EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationModelState(
			jsonObj.ModelState, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "model-state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: precision string
	_, unchangedPrecision := unchangedAttrs["precision"]
	if !unchangedPrecision { // Mandatory leaf

		paramsPrecision := make([]string, len(params))
		copy(paramsPrecision, params)
		paramsPrecision = append(paramsPrecision, (string)(jsonObj.Precision))
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationPrecision", paramsPrecision...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/precision"), paramsPrecision...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "StoreTrafficMonitoringPersonDetectionApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationDevice converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationDevice(
	jsonObj *StoreTrafficMonitoringPersonDetectionApplicationDevice, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationDevice", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationPrecision converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationPrecision(
	jsonObj *StoreTrafficMonitoringPersonDetectionApplicationPrecision, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationPrecision", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationModelState converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoringPersonDetectionApplicationModelState(
	jsonObj *StoreTrafficMonitoringPersonDetectionApplicationModelState, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: active-model-file string
	if jsonObj.ActiveModelFile != nil { // Optional leaf

		paramsActiveModelFile := make([]string, len(params))
		copy(paramsActiveModelFile, params)
		stringValActiveModelFile := fmt.Sprintf("%v", *jsonObj.ActiveModelFile)

		paramsActiveModelFile = append(paramsActiveModelFile, stringValActiveModelFile)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationModelStateActiveModelFile", paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-file"), paramsActiveModelFile...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: active-model-name string
	if jsonObj.ActiveModelName != nil { // Optional leaf

		paramsActiveModelName := make([]string, len(params))
		copy(paramsActiveModelName, params)
		stringValActiveModelName := fmt.Sprintf("%v", *jsonObj.ActiveModelName)

		paramsActiveModelName = append(paramsActiveModelName, stringValActiveModelName)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringPersonDetectionApplicationModelStateActiveModelName", paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/active-model-name"), paramsActiveModelName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "StoreTrafficMonitoringPersonDetectionApplicationModelState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringRetailArea converts OAPI to gNMI.
func EncodeToGnmiStoreTrafficMonitoringRetailArea(
	jsonObj *StoreTrafficMonitoringRetailArea, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: area-ref ListKey
	_, unchangedAreaRef := unchangedAttrs["area-ref"]
	if !unchangedAreaRef { // Mandatory leaf

		paramsAreaRef := make([]string, len(params))
		copy(paramsAreaRef, params)
		stringValAreaRef := fmt.Sprintf("%v", jsonObj.AreaRef)

		paramsAreaRef = append(paramsAreaRef, stringValAreaRef)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringRetailAreaAreaRef", paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/area-ref"), paramsAreaRef...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	_, unchangedEnabled := unchangedAttrs["enabled"]
	if !unchangedEnabled { // Mandatory leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringRetailAreaEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: stream-count int
	if jsonObj.StreamCount != nil { // Optional leaf

		paramsStreamCount := make([]string, len(params))
		copy(paramsStreamCount, params)
		stringValStreamCount := fmt.Sprintf("%v", *jsonObj.StreamCount)

		paramsStreamCount = append(paramsStreamCount, stringValStreamCount)
		mpField, err := utils.CreateModelPluginObject(&mp, "StoreTrafficMonitoringRetailAreaStreamCount", paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/stream-count"), paramsStreamCount...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "StoreTrafficMonitoringRetailArea", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiStoreTrafficMonitoringRetailAreaList converts OAPI List to gNMI List.
func EncodeToGnmiStoreTrafficMonitoringRetailAreaList(
	jsonObj *StoreTrafficMonitoringRetailAreaList, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiStoreTrafficMonitoringRetailArea(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiStoreId converts OAPI to gNMI.
func EncodeToGnmiStoreId(
	jsonObj *StoreId, needKey bool, removeIndex bool, enterpriseId StoreId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = StoreId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "StoreId", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if enterpriseId != "" {
		update.Path.Target = string(enterpriseId)
	}
	updates = append(updates, update)
	return updates, nil
}

//Ignoring RequestBodyRetailArea

//Ignoring RequestBodyRetailAreaLocation

//Ignoring RequestBodyRetailAreaSource

//Ignoring RequestBodyRetailAreaSourceLocation

//Ignoring RequestBodyRetailAreaSourceVideo

//Ignoring RequestBodyShelfMonitoring

//Ignoring RequestBodyShelfMonitoringObjectDetectionApplication

//Ignoring RequestBodyShelfMonitoringRetailArea

//Ignoring RequestBodyShopperMonitoring

//Ignoring RequestBodyShopperMonitoringEmotionRecognitionApplication

//Ignoring RequestBodyShopperMonitoringFaceDetectionApplication

//Ignoring RequestBodyShopperMonitoringHeadPoseDetectionApplication

//Ignoring RequestBodyShopperMonitoringRetailArea

//Ignoring RequestBodyStoreTrafficMonitoring

//Ignoring RequestBodyStoreTrafficMonitoringPersonDetectionApplication

//Ignoring RequestBodyStoreTrafficMonitoringRetailArea

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating param-types

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating request-bodies

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating additional-properties
// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// Not generating additional-properties
