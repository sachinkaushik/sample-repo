// Package sra_0_2_x provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/intel-innersource/frameworks.edge.one-intel-edge.maestro-app.roc.rocaas-tools/rocaas-cli version (devel) DO NOT EDIT.
package sra_0_2_x

import (
	"encoding/json"
	"fmt"
)

// Defines values for RetailAreaLocationCoordinateSystem.
const (
	RetailAreaLocationCoordinateSystemGridBottomLeft RetailAreaLocationCoordinateSystem = "grid-bottom-left"
	RetailAreaLocationCoordinateSystemGridTopLeft    RetailAreaLocationCoordinateSystem = "grid-top-left"
	RetailAreaLocationCoordinateSystemLatLong        RetailAreaLocationCoordinateSystem = "lat-long"
)

// Defines values for RetailAreaSourceLocationCoordinateSystem.
const (
	RetailAreaSourceLocationCoordinateSystemGridBottomLeft RetailAreaSourceLocationCoordinateSystem = "grid-bottom-left"
	RetailAreaSourceLocationCoordinateSystemGridTopLeft    RetailAreaSourceLocationCoordinateSystem = "grid-top-left"
	RetailAreaSourceLocationCoordinateSystemLatLong        RetailAreaSourceLocationCoordinateSystem = "lat-long"
)

// Defines values for RetailAreaSourceVideoSourceType.
const (
	Device RetailAreaSourceVideoSourceType = "device"
	File   RetailAreaSourceVideoSourceType = "file"
	Sample RetailAreaSourceVideoSourceType = "sample"
	Stream RetailAreaSourceVideoSourceType = "stream"
)

// Defines values for ShelfMonitoringObjectDetectionApplicationDevice.
const (
	ShelfMonitoringObjectDetectionApplicationDeviceCpu ShelfMonitoringObjectDetectionApplicationDevice = "cpu"
	ShelfMonitoringObjectDetectionApplicationDeviceGpu ShelfMonitoringObjectDetectionApplicationDevice = "gpu"
	ShelfMonitoringObjectDetectionApplicationDeviceVpu ShelfMonitoringObjectDetectionApplicationDevice = "vpu"
)

// Defines values for ShelfMonitoringObjectDetectionApplicationPrecision.
const (
	ShelfMonitoringObjectDetectionApplicationPrecisionFp16 ShelfMonitoringObjectDetectionApplicationPrecision = "fp16"
	ShelfMonitoringObjectDetectionApplicationPrecisionFp32 ShelfMonitoringObjectDetectionApplicationPrecision = "fp32"
	ShelfMonitoringObjectDetectionApplicationPrecisionFp8  ShelfMonitoringObjectDetectionApplicationPrecision = "fp8"
)

// Defines values for ShopperMonitoringEmotionRecognitionApplicationDevice.
const (
	ShopperMonitoringEmotionRecognitionApplicationDeviceCpu ShopperMonitoringEmotionRecognitionApplicationDevice = "cpu"
	ShopperMonitoringEmotionRecognitionApplicationDeviceGpu ShopperMonitoringEmotionRecognitionApplicationDevice = "gpu"
	ShopperMonitoringEmotionRecognitionApplicationDeviceVpu ShopperMonitoringEmotionRecognitionApplicationDevice = "vpu"
)

// Defines values for ShopperMonitoringEmotionRecognitionApplicationPrecision.
const (
	ShopperMonitoringEmotionRecognitionApplicationPrecisionFp16 ShopperMonitoringEmotionRecognitionApplicationPrecision = "fp16"
	ShopperMonitoringEmotionRecognitionApplicationPrecisionFp32 ShopperMonitoringEmotionRecognitionApplicationPrecision = "fp32"
	ShopperMonitoringEmotionRecognitionApplicationPrecisionFp8  ShopperMonitoringEmotionRecognitionApplicationPrecision = "fp8"
)

// Defines values for ShopperMonitoringFaceDetectionApplicationDevice.
const (
	ShopperMonitoringFaceDetectionApplicationDeviceCpu ShopperMonitoringFaceDetectionApplicationDevice = "cpu"
	ShopperMonitoringFaceDetectionApplicationDeviceGpu ShopperMonitoringFaceDetectionApplicationDevice = "gpu"
	ShopperMonitoringFaceDetectionApplicationDeviceVpu ShopperMonitoringFaceDetectionApplicationDevice = "vpu"
)

// Defines values for ShopperMonitoringFaceDetectionApplicationPrecision.
const (
	ShopperMonitoringFaceDetectionApplicationPrecisionFp16 ShopperMonitoringFaceDetectionApplicationPrecision = "fp16"
	ShopperMonitoringFaceDetectionApplicationPrecisionFp32 ShopperMonitoringFaceDetectionApplicationPrecision = "fp32"
	ShopperMonitoringFaceDetectionApplicationPrecisionFp8  ShopperMonitoringFaceDetectionApplicationPrecision = "fp8"
)

// Defines values for ShopperMonitoringHeadPoseDetectionApplicationDevice.
const (
	ShopperMonitoringHeadPoseDetectionApplicationDeviceCpu ShopperMonitoringHeadPoseDetectionApplicationDevice = "cpu"
	ShopperMonitoringHeadPoseDetectionApplicationDeviceGpu ShopperMonitoringHeadPoseDetectionApplicationDevice = "gpu"
	ShopperMonitoringHeadPoseDetectionApplicationDeviceVpu ShopperMonitoringHeadPoseDetectionApplicationDevice = "vpu"
)

// Defines values for ShopperMonitoringHeadPoseDetectionApplicationPrecision.
const (
	ShopperMonitoringHeadPoseDetectionApplicationPrecisionFp16 ShopperMonitoringHeadPoseDetectionApplicationPrecision = "fp16"
	ShopperMonitoringHeadPoseDetectionApplicationPrecisionFp32 ShopperMonitoringHeadPoseDetectionApplicationPrecision = "fp32"
	ShopperMonitoringHeadPoseDetectionApplicationPrecisionFp8  ShopperMonitoringHeadPoseDetectionApplicationPrecision = "fp8"
)

// Defines values for StoreTrafficMonitoringPersonDetectionApplicationDevice.
const (
	Cpu StoreTrafficMonitoringPersonDetectionApplicationDevice = "cpu"
	Gpu StoreTrafficMonitoringPersonDetectionApplicationDevice = "gpu"
	Vpu StoreTrafficMonitoringPersonDetectionApplicationDevice = "vpu"
)

// Defines values for StoreTrafficMonitoringPersonDetectionApplicationPrecision.
const (
	Fp16 StoreTrafficMonitoringPersonDetectionApplicationPrecision = "fp16"
	Fp32 StoreTrafficMonitoringPersonDetectionApplicationPrecision = "fp32"
	Fp8  StoreTrafficMonitoringPersonDetectionApplicationPrecision = "fp8"
)

// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: LicenseRef-Intel

// both the additional property 'unchanged' and the 'store-id'
type AdditionalPropertiesUnchTarget struct {
	// an override of the store-id (target)
	StoreId *string `json:"store-id,omitempty"`

	// A comma seperated list of unchanged mandatory attribute names
	Unchanged *string `json:"unchanged,omitempty"`
}

// Optionally specify a store-id other than the default (only on PATCH method)
type AdditionalPropertyStoreId struct {
	// an override of the store-id (target)
	StoreId *string `json:"store-id,omitempty"`
}

// To optionally omit 'required' properties, add them to 'unchanged' list
type AdditionalPropertyUnchanged struct {
	// A comma seperated list of unchanged mandatory attribute names
	Unchanged *string `json:"unchanged,omitempty"`
}

// single label/value of the leafref option
type LeafRefOption struct {
	// label of the leafref option
	Label *string `json:"label,omitempty"`

	// value of the leafref option
	Value *string `json:"value,omitempty"`
}

// List of label/value of leafref options
type LeafRefOptions = []LeafRefOption

// Area is a physical place in a retail location e.g. department, floor (single)
type RetailArea struct {
	// An identifier for the retail area
	AreaId ListKey `json:"area-id"`

	// long description field
	Description *string `json:"description,omitempty"`

	// display name to use in GUI or CLI
	DisplayName *string `json:"display-name,omitempty"`

	// a URL to an image file (e.g. SVG, PNG). Optional
	Image *string `json:"image,omitempty"`

	// physical location in grid or latitude and longitude
	Location *RetailAreaLocation `json:"location,omitempty"`

	// The list of cameras (list)
	Source               *RetailAreaSourceList                `json:"source,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyStoreId `json:"-"`
}

// Area is a physical place in a retail location e.g. department, floor (list)
type RetailAreaList = []RetailArea

// physical location in grid or latitude and longitude
type RetailAreaLocation struct {
	// choice of coordinate system
	CoordinateSystem RetailAreaLocationCoordinateSystem `json:"coordinate-system"`

	// rotation in dgrees the X-Y plane clockwise from the 3 o'clock position
	OrientationX *int64 `json:"orientation-x,omitempty"`

	// The X position in grid or longitude by 10e-7
	X int64 `json:"x"`

	// The Y position in grid or latitude by 10e-7
	Y int64 `json:"y"`

	// The Z position in grid or elevation in centimetres (optional)
	Z                    *int64                                 `json:"z,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// choice of coordinate system
type RetailAreaLocationCoordinateSystem string

// The list of cameras (single)
type RetailAreaSource struct {
	// long description field
	Description *string `json:"description,omitempty"`

	// display name to use in GUI or CLI
	DisplayName *string `json:"display-name,omitempty"`

	// a URL to an image file (e.g. SVG, PNG). Optional
	Image *string `json:"image,omitempty"`

	// physical location in grid or latitude and longitude
	Location *RetailAreaSourceLocation `json:"location,omitempty"`

	// the name of the inference source
	SourceId ListKey `json:"source-id"`

	// read only attributes of the source - populated by adapter from analytics engine
	State *RetailAreaSourceState `json:"state,omitempty"`

	// attributes related to video stream
	Video *RetailAreaSourceVideo `json:"video,omitempty"`
}

// The list of cameras (list)
type RetailAreaSourceList = []RetailAreaSource

// physical location in grid or latitude and longitude
type RetailAreaSourceLocation struct {
	// choice of coordinate system
	CoordinateSystem RetailAreaSourceLocationCoordinateSystem `json:"coordinate-system"`

	// rotation in dgrees the X-Y plane clockwise from the 3 o'clock position
	OrientationX *int64 `json:"orientation-x,omitempty"`

	// The X position in grid or longitude by 10e-7
	X int64 `json:"x"`

	// The Y position in grid or latitude by 10e-7
	Y int64 `json:"y"`

	// The Z position in grid or elevation in centimetres (optional)
	Z                    *int64                                 `json:"z,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// choice of coordinate system
type RetailAreaSourceLocationCoordinateSystem string

// read only attributes of the source - populated by adapter from analytics engine
type RetailAreaSourceState struct {
	// description of error if present
	Error *string `json:"error,omitempty"`

	// date and time error last updated
	ErrorSince *string `json:"error-since,omitempty"`

	// status of the source
	Status *string `json:"status,omitempty"`
}

// attributes related to video stream
type RetailAreaSourceVideo struct {
	// the path to the inference source
	Path string `json:"path"`

	// Source type
	SourceType           RetailAreaSourceVideoSourceType        `json:"source-type"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// Source type
type RetailAreaSourceVideoSourceType string

// Configure Application to count objects in shelf
type ShelfMonitoring struct {
	// mark the default source
	Default *string `json:"default,omitempty"`

	// Pipeline enabled
	Enable bool `json:"enable"`

	// configuration of Object Detection
	ObjectDetectionApplication *ShelfMonitoringObjectDetectionApplication `json:"object-detection-application,omitempty"`

	// a list of references to sources (list)
	RetailArea           *ShelfMonitoringRetailAreaList            `json:"retail-area,omitempty"`
	AdditionalProperties map[string]AdditionalPropertiesUnchTarget `json:"-"`
}

// configuration of Object Detection
type ShelfMonitoringObjectDetectionApplication struct {
	// Choice of node device
	Device ShelfMonitoringObjectDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *ShelfMonitoringObjectDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            ShelfMonitoringObjectDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged             `json:"-"`
}

// Choice of node device
type ShelfMonitoringObjectDetectionApplicationDevice string

// Choice of node device
type ShelfMonitoringObjectDetectionApplicationPrecision string

// read only values about the models state
type ShelfMonitoringObjectDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// a list of references to sources (single)
type ShelfMonitoringRetailArea struct {
	// reference to a retail-area
	AreaRef ListKey `json:"area-ref"`

	// retail-area sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type ShelfMonitoringRetailAreaList = []ShelfMonitoringRetailArea

// Configure the Application to recognize Shopper Emotions
type ShopperMonitoring struct {
	// mark the default source
	Default *string `json:"default,omitempty"`

	// configuration of emotion recognition
	EmotionRecognitionApplication *ShopperMonitoringEmotionRecognitionApplication `json:"emotion-recognition-application,omitempty"`

	// Pipeline enabled
	Enable bool `json:"enable"`

	// configuration of face detection
	FaceDetectionApplication *ShopperMonitoringFaceDetectionApplication `json:"face-detection-application,omitempty"`

	// configuration of head pose detection
	HeadPoseDetectionApplication *ShopperMonitoringHeadPoseDetectionApplication `json:"head-pose-detection-application,omitempty"`

	// a list of references to sources (list)
	RetailArea           *ShopperMonitoringRetailAreaList          `json:"retail-area,omitempty"`
	AdditionalProperties map[string]AdditionalPropertiesUnchTarget `json:"-"`
}

// configuration of emotion recognition
type ShopperMonitoringEmotionRecognitionApplication struct {
	// Choice of node device
	Device ShopperMonitoringEmotionRecognitionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *ShopperMonitoringEmotionRecognitionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            ShopperMonitoringEmotionRecognitionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged                  `json:"-"`
}

// Choice of node device
type ShopperMonitoringEmotionRecognitionApplicationDevice string

// Choice of node device
type ShopperMonitoringEmotionRecognitionApplicationPrecision string

// read only values about the models state
type ShopperMonitoringEmotionRecognitionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// configuration of face detection
type ShopperMonitoringFaceDetectionApplication struct {
	// Choice of node device
	Device ShopperMonitoringFaceDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *ShopperMonitoringFaceDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            ShopperMonitoringFaceDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged             `json:"-"`
}

// Choice of node device
type ShopperMonitoringFaceDetectionApplicationDevice string

// Choice of node device
type ShopperMonitoringFaceDetectionApplicationPrecision string

// read only values about the models state
type ShopperMonitoringFaceDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// configuration of head pose detection
type ShopperMonitoringHeadPoseDetectionApplication struct {
	// Choice of node device
	Device ShopperMonitoringHeadPoseDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *ShopperMonitoringHeadPoseDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            ShopperMonitoringHeadPoseDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged                 `json:"-"`
}

// Choice of node device
type ShopperMonitoringHeadPoseDetectionApplicationDevice string

// Choice of node device
type ShopperMonitoringHeadPoseDetectionApplicationPrecision string

// read only values about the models state
type ShopperMonitoringHeadPoseDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// a list of references to sources (single)
type ShopperMonitoringRetailArea struct {
	// reference to a retail-area
	AreaRef ListKey `json:"area-ref"`

	// retail-area sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type ShopperMonitoringRetailAreaList = []ShopperMonitoringRetailArea

// Configure of Application to display shopper count
type StoreTrafficMonitoring struct {
	// mark the default source
	Default *string `json:"default,omitempty"`

	// Pipeline enabled
	Enable bool `json:"enable"`

	// configuration Person Detection
	PersonDetectionApplication *StoreTrafficMonitoringPersonDetectionApplication `json:"person-detection-application,omitempty"`

	// a list of references to sources (list)
	RetailArea           *StoreTrafficMonitoringRetailAreaList     `json:"retail-area,omitempty"`
	AdditionalProperties map[string]AdditionalPropertiesUnchTarget `json:"-"`
}

// configuration Person Detection
type StoreTrafficMonitoringPersonDetectionApplication struct {
	// Choice of node device
	Device StoreTrafficMonitoringPersonDetectionApplicationDevice `json:"device"`

	// Enter model name. Leave blank to use the default model.
	// Invalid values will be ignored and the default values will be used instead.
	// This is an example of a loosely coupled attribute. State values are needed below
	// to show the actual result of the configuration
	Model *string `json:"model,omitempty"`

	// read only values about the models state
	ModelState *StoreTrafficMonitoringPersonDetectionApplicationModelState `json:"model-state,omitempty"`

	// Choice of node device
	Precision            StoreTrafficMonitoringPersonDetectionApplicationPrecision `json:"precision"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged                    `json:"-"`
}

// Choice of node device
type StoreTrafficMonitoringPersonDetectionApplicationDevice string

// Choice of node device
type StoreTrafficMonitoringPersonDetectionApplicationPrecision string

// read only values about the models state
type StoreTrafficMonitoringPersonDetectionApplicationModelState struct {
	// The file name of the model in use will be shown here
	ActiveModelFile *string `json:"active-model-file,omitempty"`

	// The model in use will be shown here
	ActiveModelName *string `json:"active-model-name,omitempty"`
}

// a list of references to sources (single)
type StoreTrafficMonitoringRetailArea struct {
	// reference to a retail-area
	AreaRef ListKey `json:"area-ref"`

	// retail-area sources are enabled
	Enabled bool `json:"enabled"`

	// Count of streams in this source
	StreamCount          *int                                   `json:"stream-count,omitempty"`
	AdditionalProperties map[string]AdditionalPropertyUnchanged `json:"-"`
}

// a list of references to sources (list)
type StoreTrafficMonitoringRetailAreaList = []StoreTrafficMonitoringRetailArea

// store-id (target in onos-config)
type StoreId string

// Area is a physical place in a retail location e.g. department, floor (single)
type RequestBodyRetailArea = RetailArea

// physical location in grid or latitude and longitude
type RequestBodyRetailAreaLocation = RetailAreaLocation

// The list of cameras (single)
type RequestBodyRetailAreaSource = RetailAreaSource

// physical location in grid or latitude and longitude
type RequestBodyRetailAreaSourceLocation = RetailAreaSourceLocation

// attributes related to video stream
type RequestBodyRetailAreaSourceVideo = RetailAreaSourceVideo

// Configure Application to count objects in shelf
type RequestBodyShelfMonitoring = ShelfMonitoring

// configuration of Object Detection
type RequestBodyShelfMonitoringObjectDetectionApplication = ShelfMonitoringObjectDetectionApplication

// a list of references to sources (single)
type RequestBodyShelfMonitoringRetailArea = ShelfMonitoringRetailArea

// Configure the Application to recognize Shopper Emotions
type RequestBodyShopperMonitoring = ShopperMonitoring

// configuration of emotion recognition
type RequestBodyShopperMonitoringEmotionRecognitionApplication = ShopperMonitoringEmotionRecognitionApplication

// configuration of face detection
type RequestBodyShopperMonitoringFaceDetectionApplication = ShopperMonitoringFaceDetectionApplication

// configuration of head pose detection
type RequestBodyShopperMonitoringHeadPoseDetectionApplication = ShopperMonitoringHeadPoseDetectionApplication

// a list of references to sources (single)
type RequestBodyShopperMonitoringRetailArea = ShopperMonitoringRetailArea

// Configure of Application to display shopper count
type RequestBodyStoreTrafficMonitoring = StoreTrafficMonitoring

// configuration Person Detection
type RequestBodyStoreTrafficMonitoringPersonDetectionApplication = StoreTrafficMonitoringPersonDetectionApplication

// a list of references to sources (single)
type RequestBodyStoreTrafficMonitoringRetailArea = StoreTrafficMonitoringRetailArea

// ListKey a type for list keys
type ListKey string

// TargetName defines model for TargetName.
type TargetName struct {
	Name *string `json:"name,omitempty"`
}

// TargetsNames defines model for TargetsNames.
type TargetsNames []TargetName

// PostRetailAreaJSONRequestBody defines body for PostRetailArea for application/json ContentType.
type PostRetailAreaJSONRequestBody = RequestBodyRetailArea

// PostRetailAreaLocationJSONRequestBody defines body for PostRetailAreaLocation for application/json ContentType.
type PostRetailAreaLocationJSONRequestBody = RequestBodyRetailAreaLocation

// PostRetailAreaSourceJSONRequestBody defines body for PostRetailAreaSource for application/json ContentType.
type PostRetailAreaSourceJSONRequestBody = RequestBodyRetailAreaSource

// PostRetailAreaSourceLocationJSONRequestBody defines body for PostRetailAreaSourceLocation for application/json ContentType.
type PostRetailAreaSourceLocationJSONRequestBody = RequestBodyRetailAreaSourceLocation

// PostRetailAreaSourceVideoJSONRequestBody defines body for PostRetailAreaSourceVideo for application/json ContentType.
type PostRetailAreaSourceVideoJSONRequestBody = RequestBodyRetailAreaSourceVideo

// PostShelfMonitoringJSONRequestBody defines body for PostShelfMonitoring for application/json ContentType.
type PostShelfMonitoringJSONRequestBody = RequestBodyShelfMonitoring

// PostShelfMonitoringObjectDetectionApplicationJSONRequestBody defines body for PostShelfMonitoringObjectDetectionApplication for application/json ContentType.
type PostShelfMonitoringObjectDetectionApplicationJSONRequestBody = RequestBodyShelfMonitoringObjectDetectionApplication

// PostShelfMonitoringRetailAreaJSONRequestBody defines body for PostShelfMonitoringRetailArea for application/json ContentType.
type PostShelfMonitoringRetailAreaJSONRequestBody = RequestBodyShelfMonitoringRetailArea

// PostShopperMonitoringJSONRequestBody defines body for PostShopperMonitoring for application/json ContentType.
type PostShopperMonitoringJSONRequestBody = RequestBodyShopperMonitoring

// PostShopperMonitoringEmotionRecognitionApplicationJSONRequestBody defines body for PostShopperMonitoringEmotionRecognitionApplication for application/json ContentType.
type PostShopperMonitoringEmotionRecognitionApplicationJSONRequestBody = RequestBodyShopperMonitoringEmotionRecognitionApplication

// PostShopperMonitoringFaceDetectionApplicationJSONRequestBody defines body for PostShopperMonitoringFaceDetectionApplication for application/json ContentType.
type PostShopperMonitoringFaceDetectionApplicationJSONRequestBody = RequestBodyShopperMonitoringFaceDetectionApplication

// PostShopperMonitoringHeadPoseDetectionApplicationJSONRequestBody defines body for PostShopperMonitoringHeadPoseDetectionApplication for application/json ContentType.
type PostShopperMonitoringHeadPoseDetectionApplicationJSONRequestBody = RequestBodyShopperMonitoringHeadPoseDetectionApplication

// PostShopperMonitoringRetailAreaJSONRequestBody defines body for PostShopperMonitoringRetailArea for application/json ContentType.
type PostShopperMonitoringRetailAreaJSONRequestBody = RequestBodyShopperMonitoringRetailArea

// PostStoreTrafficMonitoringJSONRequestBody defines body for PostStoreTrafficMonitoring for application/json ContentType.
type PostStoreTrafficMonitoringJSONRequestBody = RequestBodyStoreTrafficMonitoring

// PostStoreTrafficMonitoringPersonDetectionApplicationJSONRequestBody defines body for PostStoreTrafficMonitoringPersonDetectionApplication for application/json ContentType.
type PostStoreTrafficMonitoringPersonDetectionApplicationJSONRequestBody = RequestBodyStoreTrafficMonitoringPersonDetectionApplication

// PostStoreTrafficMonitoringRetailAreaJSONRequestBody defines body for PostStoreTrafficMonitoringRetailArea for application/json ContentType.
type PostStoreTrafficMonitoringRetailAreaJSONRequestBody = RequestBodyStoreTrafficMonitoringRetailArea

// Getter for additional properties for RetailArea. Returns the specified
// element and whether it was found
func (a RetailArea) Get(fieldName string) (value AdditionalPropertyStoreId, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RetailArea
func (a *RetailArea) Set(fieldName string, value AdditionalPropertyStoreId) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyStoreId)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RetailArea to handle AdditionalProperties
func (a *RetailArea) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["area-id"]; found {
		err = json.Unmarshal(raw, &a.AreaId)
		if err != nil {
			return fmt.Errorf("error reading 'area-id': %w", err)
		}
		delete(object, "area-id")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["display-name"]; found {
		err = json.Unmarshal(raw, &a.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display-name': %w", err)
		}
		delete(object, "display-name")
	}

	if raw, found := object["image"]; found {
		err = json.Unmarshal(raw, &a.Image)
		if err != nil {
			return fmt.Errorf("error reading 'image': %w", err)
		}
		delete(object, "image")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyStoreId)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyStoreId
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RetailArea to handle AdditionalProperties
func (a RetailArea) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["area-id"], err = json.Marshal(a.AreaId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'area-id': %w", err)
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DisplayName != nil {
		object["display-name"], err = json.Marshal(a.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display-name': %w", err)
		}
	}

	if a.Image != nil {
		object["image"], err = json.Marshal(a.Image)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'image': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RetailAreaLocation. Returns the specified
// element and whether it was found
func (a RetailAreaLocation) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RetailAreaLocation
func (a *RetailAreaLocation) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RetailAreaLocation to handle AdditionalProperties
func (a *RetailAreaLocation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["coordinate-system"]; found {
		err = json.Unmarshal(raw, &a.CoordinateSystem)
		if err != nil {
			return fmt.Errorf("error reading 'coordinate-system': %w", err)
		}
		delete(object, "coordinate-system")
	}

	if raw, found := object["orientation-x"]; found {
		err = json.Unmarshal(raw, &a.OrientationX)
		if err != nil {
			return fmt.Errorf("error reading 'orientation-x': %w", err)
		}
		delete(object, "orientation-x")
	}

	if raw, found := object["x"]; found {
		err = json.Unmarshal(raw, &a.X)
		if err != nil {
			return fmt.Errorf("error reading 'x': %w", err)
		}
		delete(object, "x")
	}

	if raw, found := object["y"]; found {
		err = json.Unmarshal(raw, &a.Y)
		if err != nil {
			return fmt.Errorf("error reading 'y': %w", err)
		}
		delete(object, "y")
	}

	if raw, found := object["z"]; found {
		err = json.Unmarshal(raw, &a.Z)
		if err != nil {
			return fmt.Errorf("error reading 'z': %w", err)
		}
		delete(object, "z")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RetailAreaLocation to handle AdditionalProperties
func (a RetailAreaLocation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["coordinate-system"], err = json.Marshal(a.CoordinateSystem)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'coordinate-system': %w", err)
	}

	if a.OrientationX != nil {
		object["orientation-x"], err = json.Marshal(a.OrientationX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'orientation-x': %w", err)
		}
	}

	object["x"], err = json.Marshal(a.X)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'x': %w", err)
	}

	object["y"], err = json.Marshal(a.Y)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'y': %w", err)
	}

	if a.Z != nil {
		object["z"], err = json.Marshal(a.Z)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RetailAreaSourceLocation. Returns the specified
// element and whether it was found
func (a RetailAreaSourceLocation) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RetailAreaSourceLocation
func (a *RetailAreaSourceLocation) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RetailAreaSourceLocation to handle AdditionalProperties
func (a *RetailAreaSourceLocation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["coordinate-system"]; found {
		err = json.Unmarshal(raw, &a.CoordinateSystem)
		if err != nil {
			return fmt.Errorf("error reading 'coordinate-system': %w", err)
		}
		delete(object, "coordinate-system")
	}

	if raw, found := object["orientation-x"]; found {
		err = json.Unmarshal(raw, &a.OrientationX)
		if err != nil {
			return fmt.Errorf("error reading 'orientation-x': %w", err)
		}
		delete(object, "orientation-x")
	}

	if raw, found := object["x"]; found {
		err = json.Unmarshal(raw, &a.X)
		if err != nil {
			return fmt.Errorf("error reading 'x': %w", err)
		}
		delete(object, "x")
	}

	if raw, found := object["y"]; found {
		err = json.Unmarshal(raw, &a.Y)
		if err != nil {
			return fmt.Errorf("error reading 'y': %w", err)
		}
		delete(object, "y")
	}

	if raw, found := object["z"]; found {
		err = json.Unmarshal(raw, &a.Z)
		if err != nil {
			return fmt.Errorf("error reading 'z': %w", err)
		}
		delete(object, "z")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RetailAreaSourceLocation to handle AdditionalProperties
func (a RetailAreaSourceLocation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["coordinate-system"], err = json.Marshal(a.CoordinateSystem)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'coordinate-system': %w", err)
	}

	if a.OrientationX != nil {
		object["orientation-x"], err = json.Marshal(a.OrientationX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'orientation-x': %w", err)
		}
	}

	object["x"], err = json.Marshal(a.X)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'x': %w", err)
	}

	object["y"], err = json.Marshal(a.Y)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'y': %w", err)
	}

	if a.Z != nil {
		object["z"], err = json.Marshal(a.Z)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'z': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RetailAreaSourceVideo. Returns the specified
// element and whether it was found
func (a RetailAreaSourceVideo) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RetailAreaSourceVideo
func (a *RetailAreaSourceVideo) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RetailAreaSourceVideo to handle AdditionalProperties
func (a *RetailAreaSourceVideo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["source-type"]; found {
		err = json.Unmarshal(raw, &a.SourceType)
		if err != nil {
			return fmt.Errorf("error reading 'source-type': %w", err)
		}
		delete(object, "source-type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RetailAreaSourceVideo to handle AdditionalProperties
func (a RetailAreaSourceVideo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["path"], err = json.Marshal(a.Path)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'path': %w", err)
	}

	object["source-type"], err = json.Marshal(a.SourceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'source-type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShelfMonitoring. Returns the specified
// element and whether it was found
func (a ShelfMonitoring) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShelfMonitoring
func (a *ShelfMonitoring) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShelfMonitoring to handle AdditionalProperties
func (a *ShelfMonitoring) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if raw, found := object["object-detection-application"]; found {
		err = json.Unmarshal(raw, &a.ObjectDetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'object-detection-application': %w", err)
		}
		delete(object, "object-detection-application")
	}

	if raw, found := object["retail-area"]; found {
		err = json.Unmarshal(raw, &a.RetailArea)
		if err != nil {
			return fmt.Errorf("error reading 'retail-area': %w", err)
		}
		delete(object, "retail-area")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShelfMonitoring to handle AdditionalProperties
func (a ShelfMonitoring) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	if a.ObjectDetectionApplication != nil {
		object["object-detection-application"], err = json.Marshal(a.ObjectDetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'object-detection-application': %w", err)
		}
	}

	if a.RetailArea != nil {
		object["retail-area"], err = json.Marshal(a.RetailArea)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'retail-area': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShelfMonitoringObjectDetectionApplication. Returns the specified
// element and whether it was found
func (a ShelfMonitoringObjectDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShelfMonitoringObjectDetectionApplication
func (a *ShelfMonitoringObjectDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShelfMonitoringObjectDetectionApplication to handle AdditionalProperties
func (a *ShelfMonitoringObjectDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShelfMonitoringObjectDetectionApplication to handle AdditionalProperties
func (a ShelfMonitoringObjectDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShelfMonitoringRetailArea. Returns the specified
// element and whether it was found
func (a ShelfMonitoringRetailArea) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShelfMonitoringRetailArea
func (a *ShelfMonitoringRetailArea) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShelfMonitoringRetailArea to handle AdditionalProperties
func (a *ShelfMonitoringRetailArea) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["area-ref"]; found {
		err = json.Unmarshal(raw, &a.AreaRef)
		if err != nil {
			return fmt.Errorf("error reading 'area-ref': %w", err)
		}
		delete(object, "area-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShelfMonitoringRetailArea to handle AdditionalProperties
func (a ShelfMonitoringRetailArea) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["area-ref"], err = json.Marshal(a.AreaRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'area-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShopperMonitoring. Returns the specified
// element and whether it was found
func (a ShopperMonitoring) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShopperMonitoring
func (a *ShopperMonitoring) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShopperMonitoring to handle AdditionalProperties
func (a *ShopperMonitoring) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["emotion-recognition-application"]; found {
		err = json.Unmarshal(raw, &a.EmotionRecognitionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'emotion-recognition-application': %w", err)
		}
		delete(object, "emotion-recognition-application")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if raw, found := object["face-detection-application"]; found {
		err = json.Unmarshal(raw, &a.FaceDetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'face-detection-application': %w", err)
		}
		delete(object, "face-detection-application")
	}

	if raw, found := object["head-pose-detection-application"]; found {
		err = json.Unmarshal(raw, &a.HeadPoseDetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'head-pose-detection-application': %w", err)
		}
		delete(object, "head-pose-detection-application")
	}

	if raw, found := object["retail-area"]; found {
		err = json.Unmarshal(raw, &a.RetailArea)
		if err != nil {
			return fmt.Errorf("error reading 'retail-area': %w", err)
		}
		delete(object, "retail-area")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShopperMonitoring to handle AdditionalProperties
func (a ShopperMonitoring) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	if a.EmotionRecognitionApplication != nil {
		object["emotion-recognition-application"], err = json.Marshal(a.EmotionRecognitionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'emotion-recognition-application': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	if a.FaceDetectionApplication != nil {
		object["face-detection-application"], err = json.Marshal(a.FaceDetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'face-detection-application': %w", err)
		}
	}

	if a.HeadPoseDetectionApplication != nil {
		object["head-pose-detection-application"], err = json.Marshal(a.HeadPoseDetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'head-pose-detection-application': %w", err)
		}
	}

	if a.RetailArea != nil {
		object["retail-area"], err = json.Marshal(a.RetailArea)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'retail-area': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShopperMonitoringEmotionRecognitionApplication. Returns the specified
// element and whether it was found
func (a ShopperMonitoringEmotionRecognitionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShopperMonitoringEmotionRecognitionApplication
func (a *ShopperMonitoringEmotionRecognitionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShopperMonitoringEmotionRecognitionApplication to handle AdditionalProperties
func (a *ShopperMonitoringEmotionRecognitionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShopperMonitoringEmotionRecognitionApplication to handle AdditionalProperties
func (a ShopperMonitoringEmotionRecognitionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShopperMonitoringFaceDetectionApplication. Returns the specified
// element and whether it was found
func (a ShopperMonitoringFaceDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShopperMonitoringFaceDetectionApplication
func (a *ShopperMonitoringFaceDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShopperMonitoringFaceDetectionApplication to handle AdditionalProperties
func (a *ShopperMonitoringFaceDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShopperMonitoringFaceDetectionApplication to handle AdditionalProperties
func (a ShopperMonitoringFaceDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShopperMonitoringHeadPoseDetectionApplication. Returns the specified
// element and whether it was found
func (a ShopperMonitoringHeadPoseDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShopperMonitoringHeadPoseDetectionApplication
func (a *ShopperMonitoringHeadPoseDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShopperMonitoringHeadPoseDetectionApplication to handle AdditionalProperties
func (a *ShopperMonitoringHeadPoseDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShopperMonitoringHeadPoseDetectionApplication to handle AdditionalProperties
func (a ShopperMonitoringHeadPoseDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ShopperMonitoringRetailArea. Returns the specified
// element and whether it was found
func (a ShopperMonitoringRetailArea) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ShopperMonitoringRetailArea
func (a *ShopperMonitoringRetailArea) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ShopperMonitoringRetailArea to handle AdditionalProperties
func (a *ShopperMonitoringRetailArea) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["area-ref"]; found {
		err = json.Unmarshal(raw, &a.AreaRef)
		if err != nil {
			return fmt.Errorf("error reading 'area-ref': %w", err)
		}
		delete(object, "area-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ShopperMonitoringRetailArea to handle AdditionalProperties
func (a ShopperMonitoringRetailArea) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["area-ref"], err = json.Marshal(a.AreaRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'area-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StoreTrafficMonitoring. Returns the specified
// element and whether it was found
func (a StoreTrafficMonitoring) Get(fieldName string) (value AdditionalPropertiesUnchTarget, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StoreTrafficMonitoring
func (a *StoreTrafficMonitoring) Set(fieldName string, value AdditionalPropertiesUnchTarget) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StoreTrafficMonitoring to handle AdditionalProperties
func (a *StoreTrafficMonitoring) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["enable"]; found {
		err = json.Unmarshal(raw, &a.Enable)
		if err != nil {
			return fmt.Errorf("error reading 'enable': %w", err)
		}
		delete(object, "enable")
	}

	if raw, found := object["person-detection-application"]; found {
		err = json.Unmarshal(raw, &a.PersonDetectionApplication)
		if err != nil {
			return fmt.Errorf("error reading 'person-detection-application': %w", err)
		}
		delete(object, "person-detection-application")
	}

	if raw, found := object["retail-area"]; found {
		err = json.Unmarshal(raw, &a.RetailArea)
		if err != nil {
			return fmt.Errorf("error reading 'retail-area': %w", err)
		}
		delete(object, "retail-area")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertiesUnchTarget)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertiesUnchTarget
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StoreTrafficMonitoring to handle AdditionalProperties
func (a StoreTrafficMonitoring) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Default != nil {
		object["default"], err = json.Marshal(a.Default)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'default': %w", err)
		}
	}

	object["enable"], err = json.Marshal(a.Enable)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enable': %w", err)
	}

	if a.PersonDetectionApplication != nil {
		object["person-detection-application"], err = json.Marshal(a.PersonDetectionApplication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'person-detection-application': %w", err)
		}
	}

	if a.RetailArea != nil {
		object["retail-area"], err = json.Marshal(a.RetailArea)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'retail-area': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StoreTrafficMonitoringPersonDetectionApplication. Returns the specified
// element and whether it was found
func (a StoreTrafficMonitoringPersonDetectionApplication) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StoreTrafficMonitoringPersonDetectionApplication
func (a *StoreTrafficMonitoringPersonDetectionApplication) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StoreTrafficMonitoringPersonDetectionApplication to handle AdditionalProperties
func (a *StoreTrafficMonitoringPersonDetectionApplication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device"]; found {
		err = json.Unmarshal(raw, &a.Device)
		if err != nil {
			return fmt.Errorf("error reading 'device': %w", err)
		}
		delete(object, "device")
	}

	if raw, found := object["model"]; found {
		err = json.Unmarshal(raw, &a.Model)
		if err != nil {
			return fmt.Errorf("error reading 'model': %w", err)
		}
		delete(object, "model")
	}

	if raw, found := object["model-state"]; found {
		err = json.Unmarshal(raw, &a.ModelState)
		if err != nil {
			return fmt.Errorf("error reading 'model-state': %w", err)
		}
		delete(object, "model-state")
	}

	if raw, found := object["precision"]; found {
		err = json.Unmarshal(raw, &a.Precision)
		if err != nil {
			return fmt.Errorf("error reading 'precision': %w", err)
		}
		delete(object, "precision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StoreTrafficMonitoringPersonDetectionApplication to handle AdditionalProperties
func (a StoreTrafficMonitoringPersonDetectionApplication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["device"], err = json.Marshal(a.Device)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'device': %w", err)
	}

	if a.Model != nil {
		object["model"], err = json.Marshal(a.Model)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model': %w", err)
		}
	}

	if a.ModelState != nil {
		object["model-state"], err = json.Marshal(a.ModelState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'model-state': %w", err)
		}
	}

	object["precision"], err = json.Marshal(a.Precision)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'precision': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StoreTrafficMonitoringRetailArea. Returns the specified
// element and whether it was found
func (a StoreTrafficMonitoringRetailArea) Get(fieldName string) (value AdditionalPropertyUnchanged, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StoreTrafficMonitoringRetailArea
func (a *StoreTrafficMonitoringRetailArea) Set(fieldName string, value AdditionalPropertyUnchanged) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StoreTrafficMonitoringRetailArea to handle AdditionalProperties
func (a *StoreTrafficMonitoringRetailArea) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["area-ref"]; found {
		err = json.Unmarshal(raw, &a.AreaRef)
		if err != nil {
			return fmt.Errorf("error reading 'area-ref': %w", err)
		}
		delete(object, "area-ref")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["stream-count"]; found {
		err = json.Unmarshal(raw, &a.StreamCount)
		if err != nil {
			return fmt.Errorf("error reading 'stream-count': %w", err)
		}
		delete(object, "stream-count")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AdditionalPropertyUnchanged)
		for fieldName, fieldBuf := range object {
			var fieldVal AdditionalPropertyUnchanged
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StoreTrafficMonitoringRetailArea to handle AdditionalProperties
func (a StoreTrafficMonitoringRetailArea) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["area-ref"], err = json.Marshal(a.AreaRef)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'area-ref': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	if a.StreamCount != nil {
		object["stream-count"], err = json.Marshal(a.StreamCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stream-count': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
